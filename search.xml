<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式原则</title>
      <link href="/posts/2060/"/>
      <url>/posts/2060/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="单一职责原则">单一职责原则</h2><p><strong style="color:#fcc307;">一个类应该有且仅有一个引起它变化的原因</strong></p><h3 id="优点">优点</h3><h4 id="降低类的复杂度">降低类的复杂度</h4><p>一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</p><h4 id="提高类的可读性">提高类的可读性</h4><p>复杂性降低，自然其可读性会提高。</p><h4 id="提高系统的可维护性">提高系统的可维护性</h4><p>可读性提高，那自然更容易维护了。</p><h4 id="变更引起的风险降低">变更引起的风险降低</h4><p>变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</p><h3 id="实例">实例</h3><p>某游戏中有一个交易模块，有购买和出售两种功能，结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stuff</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">double</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Stuff</span>(string n, <span class="type">double</span> v):<span class="built_in">name</span>(n),<span class="built_in">value</span>(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tradeMode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(Stuff stuff)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(money &gt;= stuff.value)&#123;</span><br><span class="line">                money -= stuff.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(Stuff stuff)</span></span>&#123;</span><br><span class="line">            money += stuff.value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    money = <span class="number">1000</span>;</span><br><span class="line">    <span class="function">Stuff <span class="title">food</span><span class="params">(<span class="string">&quot;食物&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    tradeMode tm;</span><br><span class="line">    </span><br><span class="line">    tm.<span class="built_in">buy</span>(food);</span><br><span class="line">    cout&lt;&lt;money&lt;&lt;endl; <span class="comment">// 900</span></span><br><span class="line">    tm.<span class="built_in">sell</span>(food);</span><br><span class="line">    cout&lt;&lt;money&lt;&lt;endl; <span class="comment">// 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过了一段时间开发人员觉得出售是原价的话，很多人会把商品当存钱罐来用不太好，于是修改出售价格为原价的80%，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(Stuff stuff)</span></span>&#123;</span><br><span class="line">          money += stuff.value*<span class="number">0.8</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>运行结果变为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tm.<span class="built_in">buy</span>(food);</span><br><span class="line">cout&lt;&lt;money&lt;&lt;endl; <span class="comment">// 900</span></span><br><span class="line">tm.<span class="built_in">sell</span>(food);</span><br><span class="line">cout&lt;&lt;money&lt;&lt;endl; <span class="comment">// 980</span></span><br></pre></td></tr></table></figure><p>又过了一段时间开发人员觉得购买价格太低了，于是将购买价格增加为原价的110%。由于时间久远，在加上购买和出售的函数写在一起，两个函数还十分相似，一不小心又写到出售里去了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(Stuff stuff)</span></span>&#123;</span><br><span class="line">          money += stuff.value*<span class="number">1.1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>运行结果变为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tm.<span class="built_in">buy</span>(food);</span><br><span class="line">cout&lt;&lt;money&lt;&lt;endl; <span class="comment">// 900</span></span><br><span class="line">tm.<span class="built_in">sell</span>(food);</span><br><span class="line">cout&lt;&lt;money&lt;&lt;endl; <span class="comment">// 1100</span></span><br></pre></td></tr></table></figure><p>于是玩家可以刷钱了。。。</p><p>出现上述问题的原因就是购买和出售的功能写在一起，修改购买或者出售都会修改tradeMode类，稍有不慎就会导致修改了其他功能。</p><p>运用单一职责原则可以解决这个问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">buyMode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(Stuff stuff)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(money &gt;= stuff.value)&#123;</span><br><span class="line">                money -= stuff.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sellMode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(Stuff stuff)</span></span>&#123;</span><br><span class="line">            money += stuff.value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将原来的tradeMode拆分为buyMode和sellMode，各自实现独立的功能。这时如果需要修改方法只需要找对应的类即可。</p><hr><p>单一职责原则说白了就是让一个类，接口或者方法只实现一种功能，从而实现解耦和增强内聚来利于软件维护。</p><h2 id="开闭性原则">开闭性原则</h2><p><strong style="color:#fcc307;">软件实体应当对扩展开放，对修改关闭</strong></p><h3 id="优点-2">优点</h3><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p><h4 id="对软件测试的影响">对软件测试的影响</h4><p>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</p><h4 id="可以提高代码的可复用性">可以提高代码的可复用性</h4><p>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</p><h4 id="可以提高软件的可维护性">可以提高软件的可维护性</h4><p>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p><h3 id="实例-2">实例</h3><p>某游戏中有技能系统，释放不同的技能通过一个技能释放类来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">skillLauncher</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fireBall</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发动火球&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brightBlade</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发动光刃&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    skillLauncher sl;</span><br><span class="line">    sl.<span class="built_in">fireBall</span>(); <span class="comment">// 发动火球</span></span><br><span class="line">    sl.<span class="built_in">brightBlade</span>(); <span class="comment">// 发动光刃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来游戏更新添加了一个“冰盾”的技能，这时游戏已经进行过测试了。如果修改skillLauncher类来加一个skillShield的方法，需要重新进行测试。毕竟无法确定修改过的类是否在其他地方会出现问题。而且随着更新添加新功能，需要频繁修改类，软件的稳定性必然会下降。</p><p>如果使用开闭性原则设计，则可以抽象出skillLauncher类，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">skillLauncher</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">launchSkill</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fireBall</span> : <span class="keyword">public</span> skillLauncher&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">launchSkill</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发动火球&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">brightBlade</span> : <span class="keyword">public</span> skillLauncher&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">launchSkill</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发动光刃&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    skillLauncher* fb = <span class="keyword">new</span> fireBall;</span><br><span class="line">    fb-&gt;<span class="built_in">launchSkill</span>();</span><br><span class="line">    <span class="keyword">delete</span> fb;</span><br><span class="line"></span><br><span class="line">    skillLauncher* bb = <span class="keyword">new</span> brightBlade;</span><br><span class="line">    bb-&gt;<span class="built_in">launchSkill</span>();</span><br><span class="line">    <span class="keyword">delete</span> bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各个技能类继承于技能释放这个抽象类，实现launchSkill()的纯虚函数来释放自己类的技能，这时新增一个技能只需要新增一个技能类即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">iceShield</span> : <span class="keyword">public</span> skillLauncher&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">launchSkill</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;发动冰盾&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>开闭性原则说白了就是不要修改原来没有问题的类，而是在需要添加功能时新增类，从而使得软件开发效率提高。</p><h2 id="里氏代换原则">里氏代换原则</h2><p><strong style="color:#fcc307;">继承必须确保超类所拥有的性质在子类中仍然成立</strong></p><h3 id="优点-3">优点</h3><p>里氏替换原则的主要作用如下。</p><h4 id="克服了继承中重写父类造成的可复用性变差的缺点">克服了继承中重写父类造成的可复用性变差的缺点</h4><p>里氏替换原则是实现开闭原则的重要方式之一。</p><p>里氏替换原则要求不要重写父类已经存在定义的属性方法来继承，这时所有用到父类的地方完全可由子类代替，从而实现了可复用性。</p><h4 id="是动作正确性的保证">是动作正确性的保证</h4><p>即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</p><p>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</p><h3 id="实例-3">实例</h3><p>假设游戏中有一关需要普通宝剑的伤害大于等于100才能通过，游戏中普通宝剑类有挥砍伤害，同时该关卡提供了一个道具，使用道具可以让普通宝剑的伤害提升到100。</p><p>但有一种特殊的宝剑叫飞剑，它没有挥砍伤害（始终为0），但有投掷伤害，道具可以让投掷伤害提升到100。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">normalSword</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> cutDamage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">useProp</span><span class="params">(<span class="type">double</span> d)</span></span>&#123;</span><br><span class="line">            cutDamage = d;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">flySword</span> : <span class="keyword">public</span> normalSword&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> throwDamage;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">useProp</span><span class="params">(<span class="type">double</span> d)</span></span>&#123;</span><br><span class="line">            cutDamage = <span class="number">0</span>;</span><br><span class="line">            throwDamage = d;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getThrough</span><span class="params">(normalSword&amp; n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n.cutDamage &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;通过&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;不通过&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    normalSword ns;</span><br><span class="line">    flySword fs;</span><br><span class="line"></span><br><span class="line">    ns.<span class="built_in">useProp</span>(<span class="number">100.0</span>);</span><br><span class="line">    fs.<span class="built_in">useProp</span>(<span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getThrough</span>(ns); <span class="comment">// 通过</span></span><br><span class="line">    <span class="built_in">getThrough</span>(fs); <span class="comment">// 不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然以上是为了举例而写的代码。在逻辑上，可能飞剑是一种特殊的宝剑，所以飞剑应该是普通宝剑的子类说的通。但根据里氏代换原则，基类的性质应该在派生类中完全体现，也就是说派生类不能随意更改在基类中实现的方法和属性。</p><p>所以飞剑在实现上并不应该是普通宝剑的子类，但飞剑和普通宝剑仍有一些共同的地方，应该定义一个更加抽象的类，基于此类派生出普通宝剑和飞剑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> damage;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">useProp</span><span class="params">(<span class="type">double</span> d)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">normalSword</span> : <span class="keyword">public</span> Weapon&#123;</span><br><span class="line">    <span class="type">double</span> cutDamage;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">useProp</span><span class="params">(<span class="type">double</span> d)</span></span>&#123;</span><br><span class="line">            cutDamage = d;</span><br><span class="line">            damage = cutDamage;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">flySword</span> : <span class="keyword">public</span> Weapon&#123;</span><br><span class="line">    <span class="type">double</span> throwDamage;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">useProp</span><span class="params">(<span class="type">double</span> d)</span></span>&#123;</span><br><span class="line">            throwDamage = d;</span><br><span class="line">            damage = throwDamage;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getThrough</span><span class="params">(Weapon* s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;damage &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;通过&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;不通过&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Weapon* fs = <span class="keyword">new</span> flySword;</span><br><span class="line">    Weapon* ns = <span class="keyword">new</span> normalSword;</span><br><span class="line"></span><br><span class="line">    ns-&gt;<span class="built_in">useProp</span>(<span class="number">100.0</span>);</span><br><span class="line">    fs-&gt;<span class="built_in">useProp</span>(<span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getThrough</span>(ns); <span class="comment">// 通过</span></span><br><span class="line">    <span class="built_in">getThrough</span>(fs); <span class="comment">// 通过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> fs;</span><br><span class="line">    <span class="keyword">delete</span> ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>里氏代换原则说白了就是在面向对象中</p><p>如果一个基类确实是有自己独特功能的，派生类不要重写这些独特功能。</p><p>如果一个基类不需要独特功能，就将基类设为抽象类，用派生类对象代表基类对象。</p><h2 id="依赖倒置原则">依赖倒置原则</h2><p><strong style="color:#fcc307;">高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong></p><p><strong style="color:#fcc307;">抽象不应该依赖细节，细节应该依赖抽象</strong></p><h3 id="优点-4">优点</h3><h4 id="降低模块间的耦合性">降低模块间的耦合性</h4><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合</p><h4 id="提高系统的稳定性">提高系统的稳定性</h4><p>抽象模块具有很高的稳定性、可重用性</p><h4 id="降低并行开发引起的风险">降低并行开发引起的风险</h4><p>依赖倒置对于并行开发非常重要，可以说是必不可少。在多个人一起进行开发的时候，如果没有抽象类或者接口，开发只能按照先后次序进行。</p><h3 id="实例-4">实例</h3><p>游戏中有一个需求，实现玩家喝药水。如果直接面向需求（业务）编程，需要创建一个治疗药水类，一个加速药水类，一个玩家类，然后在玩家类中分别实现喝两种药水的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">healPotion</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">used</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;治疗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speedPotion</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">used</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;加速&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">player</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">drinkHealPotion</span><span class="params">(healPotion&amp; hp)</span></span>&#123;</span><br><span class="line">            hp.<span class="built_in">used</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">drinkSpeedPotion</span><span class="params">(speedPotion&amp; sp)</span></span>&#123;</span><br><span class="line">            sp.<span class="built_in">used</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    player p1;</span><br><span class="line">    healPotion h;</span><br><span class="line">    speedPotion s;</span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">drinkHealPotion</span>(h); <span class="comment">// 治疗</span></span><br><span class="line">    p1.<span class="built_in">drinkSpeedPotion</span>(s); <span class="comment">// 加速</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果游戏修改了需求，除了玩家还有协助者，协助者也可以喝药水，同时多了一种抗性药水。这时不仅需要修改玩家类加入实现喝抗性药水的方法，违反了开闭性原则，还需要增加协助者类，虽然协助者类没有影响开闭原则，但需要实现各种药水的方法，关系十分混乱。</p><p>根据依赖倒转原则，可以添加一层接口层，让实现层面向接口层编程，业务层也面向接口层编程，这样就隔离开实现层和业务层，逻辑就十分清晰了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Potion</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">used</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drinkPotion</span><span class="params">(Potion* p)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现层</span></span><br><span class="line"><span class="comment">// Potion</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">healPotion</span> : <span class="keyword">public</span> Potion&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">used</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;治疗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speedPotion</span> : <span class="keyword">public</span> Potion&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">used</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;加速&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Character</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">player</span> : <span class="keyword">public</span> Character&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drinkPotion</span><span class="params">(Potion *p)</span></span>&#123;</span><br><span class="line">            p-&gt;<span class="built_in">used</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Potion* hp = <span class="keyword">new</span> healPotion;</span><br><span class="line">    Potion* sp = <span class="keyword">new</span> speedPotion;</span><br><span class="line"></span><br><span class="line">    Character* p1 = <span class="keyword">new</span> player;</span><br><span class="line"></span><br><span class="line">    p1-&gt;<span class="built_in">drinkPotion</span>(hp); <span class="comment">// 治疗</span></span><br><span class="line">    p1-&gt;<span class="built_in">drinkPotion</span>(sp); <span class="comment">// 加速</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> hp;</span><br><span class="line">    <span class="keyword">delete</span> sp;</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写后如果需要添加抗性药水和协助者，只需要在实现层中添加各自的代码即可，因为只需写对抽象层的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">healPotion</span> : <span class="keyword">public</span> Potion&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">used</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;治疗&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">speedPotion</span> : <span class="keyword">public</span> Potion&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">used</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;加速&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入抗性药水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">resistancePotion</span> : <span class="keyword">public</span> Potion&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">used</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;抗性&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">player</span> : <span class="keyword">public</span> Character&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drinkPotion</span><span class="params">(Potion *p)</span></span>&#123;</span><br><span class="line">            p-&gt;<span class="built_in">used</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入协助者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">assistant</span> : <span class="keyword">public</span> Character&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drinkPotion</span><span class="params">(Potion* p)</span></span>&#123;</span><br><span class="line">            p-&gt;<span class="built_in">used</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>依赖倒置原则说白了就是让接口（抽象层）作为平台，实现层针对抽象层写实现，业务层针对抽象层提需求。</p><h2 id="接口隔离原则">接口隔离原则</h2><p><strong style="color:#fcc307;">一个类对另一个类的依赖应该建立在最小的接口上</strong></p><h3 id="优点-5">优点</h3><h4 id="能减少项目工程中的代码冗余">能减少项目工程中的代码冗余</h4><p>过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p><h4 id="提高灵活性">提高灵活性</h4><p>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性</p><h4 id="高内聚">高内聚</h4><p>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</p><h3 id="实例-5">实例</h3><p>游戏中有一个组队系统，队伍类是一个抽象接口，派生了队长和队员两种类，各自实现队伍类的全部虚函数。</p><p>但是队长和队员两种类实现的方式不同，有一些共同的如添加好友，实现是一样的。有一些如发言，实现时不同的，但都会实现。还有一些如更换模式，开始游戏，队员是没有权限的，不需要实现，但不实现自己就是抽象类无法创建对象了，故需要空实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addFriend</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">changeMode</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Team</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teamLeader</span> : <span class="keyword">public</span> Team&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chat</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;队长发言&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addFriend</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;添加好友&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;开始游戏&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">changeMode</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;更换模式&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teamMember</span> : <span class="keyword">public</span> Team&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chat</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;队员发言&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addFriend</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;添加好友&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;没有权限&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">changeMode</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;没有权限&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Team* tl = <span class="keyword">new</span> teamLeader;</span><br><span class="line">    Team* tm = <span class="keyword">new</span> teamMember;</span><br><span class="line"></span><br><span class="line">    tl-&gt;<span class="built_in">chat</span>();</span><br><span class="line">    tl-&gt;<span class="built_in">addFriend</span>();</span><br><span class="line">    tl-&gt;<span class="built_in">start</span>();</span><br><span class="line">    tl-&gt;<span class="built_in">changeMode</span>();</span><br><span class="line"></span><br><span class="line">    tm-&gt;<span class="built_in">chat</span>();</span><br><span class="line">    tm-&gt;<span class="built_in">addFriend</span>();</span><br><span class="line">    tm-&gt;<span class="built_in">start</span>();</span><br><span class="line">    tm-&gt;<span class="built_in">changeMode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tl;</span><br><span class="line">    <span class="keyword">delete</span> tm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来游戏更新后增加了组队系统的新功能，解散队伍。这时就需要在Team接口中添加解散队伍的纯虚函数，同时队长和队员类都需要重写实现该方法。但其实解散队伍这个功能跟更换模式这种一样都是队员不需要去实现的，这必然会增加开发的困难。</p><p>根据接口隔离原则，类对类的依赖应该建立在最小类上，本例的依赖就是指队长和队员对于队伍的继承关系。可以将Team类分解为两个接口，一个是队伍的高级功能，一个是队伍的一般功能，一般功能队长和队员都会继承，而高级功能只有队长继承，这时就无需队员重写不需要实现的方法了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teamSuper</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">changeMode</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">teamSuper</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teamNormal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addFriend</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">teamNormal</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teamLeader</span> : <span class="keyword">public</span> teamNormal, <span class="keyword">public</span> teamSuper&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chat</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;队长发言&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addFriend</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;添加好友&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;开始游戏&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">changeMode</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;更换模式&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teamMember</span> : <span class="keyword">public</span> teamNormal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chat</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;队员发言&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addFriend</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;添加好友&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    teamLeader* tl = <span class="keyword">new</span> teamLeader;</span><br><span class="line">    teamMember* tm = <span class="keyword">new</span> teamMember;</span><br><span class="line"></span><br><span class="line">    tl-&gt;<span class="built_in">chat</span>();</span><br><span class="line">    tl-&gt;<span class="built_in">addFriend</span>();</span><br><span class="line">    tl-&gt;<span class="built_in">start</span>();</span><br><span class="line">    tl-&gt;<span class="built_in">changeMode</span>();</span><br><span class="line"></span><br><span class="line">    tm-&gt;<span class="built_in">chat</span>();</span><br><span class="line">    tm-&gt;<span class="built_in">addFriend</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> tl;</span><br><span class="line">    <span class="keyword">delete</span> tm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解散队伍的方法也只需要在高级功能中添加，然后在队长类中实现即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teamSuper</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">changeMode</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加解散队伍</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disbandTeam</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">teamSuper</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teamLeader</span> : <span class="keyword">public</span> teamNormal, <span class="keyword">public</span> teamSuper&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">chat</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;队长发言&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addFriend</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;添加好友&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;开始游戏&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">changeMode</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;更换模式&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现解散队伍</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disbandTeam</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;解散队伍&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>接口隔离原则说白了其实和单一职责原则类似，只不过单一职责原则针对的是具体的类和方法，而接口隔离原则则是针对接口。</p><h2 id="合成复用原则">合成复用原则</h2><p><strong style="color:#fcc307;">在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong></p><h3 id="优点-6">优点</h3><h4 id="维持了类的封装性">维持了类的封装性</h4><p>因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用</p><h4 id="新旧类之间的耦合度低">新旧类之间的耦合度低</h4><p>这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口</p><h4 id="复用的灵活性高">复用的灵活性高</h4><p>这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象</p><h3 id="实例-6">实例</h3><p>游戏中角色系统的关系如下</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/23/161103.png" alt="示例关系"></p><p>根据关系图直接写很容易就能得到以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Character</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个角色&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Character&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Player</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个玩家&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> : <span class="keyword">public</span> Character&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Monster</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个怪物&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wizard</span> : <span class="keyword">public</span> Player&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Wizard</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个法师&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Warrior</span> : <span class="keyword">public</span> Player&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Warrior</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个战士&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ranger</span> : <span class="keyword">public</span> Player&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Ranger</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个游侠&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Ranger ra;</span><br><span class="line">    Wizard wi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是一个角色</span></span><br><span class="line"><span class="comment">// 我是一个玩家</span></span><br><span class="line"><span class="comment">// 我是一个游侠</span></span><br><span class="line"><span class="comment">// 我是一个角色</span></span><br><span class="line"><span class="comment">// 我是一个玩家</span></span><br><span class="line"><span class="comment">// 我是一个法师</span></span><br></pre></td></tr></table></figure><p>如上所示，一个法师又继承于玩家，玩家又继承于角色。这一连串的继承使得创建一个法师的对象就包含了一个角色对象，一个玩家对象，一个法师对象。如果游戏中可以将法师转职成游侠，那么就需要删除这么多对象然后重新创建一个对象。这显然不合理，玩家类的一些改动很容易就影响到了继承下来的这些类。</p><p>根据合成复用原则，当同样的需求组合(或聚合)和继承都能够实现时，应该优先使用组合(或聚合)。在本例中，法师，战士，游侠显然只是玩家的角色类型，使用组合的方式依然可以实现这些需求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Character</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Character</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个角色&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">playerType</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myPlayerType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wizard</span> : <span class="keyword">public</span> playerType&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myPlayerType</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;我是一个法师&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ranger</span> : <span class="keyword">public</span> playerType&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myPlayerType</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;我是一个游侠&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Warrior</span> : <span class="keyword">public</span> playerType&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myPlayerType</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;我是一个战士&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> Character&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        playerType* pt;</span><br><span class="line">        <span class="built_in">Player</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个玩家&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setPlayerType</span><span class="params">(playerType* pT)</span></span>&#123;</span><br><span class="line">            pt = pT;</span><br><span class="line">            pt-&gt;<span class="built_in">myPlayerType</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> : <span class="keyword">public</span> Character&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Monster</span>()&#123;cout&lt;&lt;<span class="string">&quot;我是一个怪物&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Wizard wi;</span><br><span class="line">    Ranger ra;</span><br><span class="line"></span><br><span class="line">    Player p1;</span><br><span class="line">    p1.<span class="built_in">setPlayerType</span>(&amp;wi);</span><br><span class="line">    p1.<span class="built_in">setPlayerType</span>(&amp;ra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是一个角色</span></span><br><span class="line"><span class="comment">// 我是一个玩家</span></span><br><span class="line"><span class="comment">// 我是一个法师</span></span><br><span class="line"><span class="comment">// 我是一个游侠</span></span><br></pre></td></tr></table></figure><p>修改过后的关系如下</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/23/163814.png" alt="示例关系"></p><hr><p>合成复用原则说白了就是组合可以减少继承带来的高耦合，所以如果同样的事情组合和继承都可以做到的话，尽量使用组合的方式。</p><h2 id="迪米特法则">迪米特法则</h2><p>又叫最少知识原则</p><p><strong style="color:#fcc307;">只与你的直接朋友交谈，不跟“陌生人”说话</strong></p><h3 id="优点-7">优点</h3><h4 id="降低了类之间的耦合度">降低了类之间的耦合度</h4><p>降低类之间的耦合，提高模块的独立性</p><h4 id="提高类的可复用率和拓展性">提高类的可复用率和拓展性</h4><p>亲合度降低，从而提高了类的可复用率和系统的扩展性</p><h3 id="实例-7">实例</h3><p>游戏中有一个扭蛋机，扭蛋机会先取随机值，再计算概率，最后将结果排序获得最终的奖品。玩家可以通过抽奖功能使用扭蛋机。代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GashaponMachine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;随机种子&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">caculateRate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;计算概率&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">orderResult</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;排序结果&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lottery</span><span class="params">(GashaponMachine &amp;gm)</span> </span>&#123;</span><br><span class="line">    gm.<span class="built_in">getRandomNumber</span>();</span><br><span class="line">    gm.<span class="built_in">caculateRate</span>();</span><br><span class="line">    gm.<span class="built_in">orderResult</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Player p1;</span><br><span class="line">  GashaponMachine gm;</span><br><span class="line">  p1.<span class="built_in">lottery</span>(gm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机种子</span></span><br><span class="line"><span class="comment">// 计算概率</span></span><br><span class="line"><span class="comment">// 排序结果</span></span><br></pre></td></tr></table></figure><p>这样写运行起来肯定没有问题，但是玩家和扭蛋机实际上只是调用关系，玩家需要做的就是使用扭蛋机的功能来抽奖，并不需要知道扭蛋机是如何实现抽奖的功能的。</p><p>同时如果扭蛋机的功能需要调整，则扭蛋机和玩家两个类都需要改动。</p><p>运用迪米特法则，当扭蛋机向调用者提供方法时，只暴露接口方法，这样玩家只调用而并不关心方法如何实现。同时一些机密的方法或者属性可以很好地隐藏住而不被外部获取。修改如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GashaponMachine</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;随机种子&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">caculateRate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;计算概率&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">orderResult</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;排序结果&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getRandomNumber</span>();</span><br><span class="line">    <span class="built_in">caculateRate</span>();</span><br><span class="line">    <span class="built_in">orderResult</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lottery</span><span class="params">(GashaponMachine &amp;gm)</span> </span>&#123; gm.<span class="built_in">doWork</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Player p1;</span><br><span class="line">  GashaponMachine gm;</span><br><span class="line">  p1.<span class="built_in">lottery</span>(gm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>玩家类只在需要抽奖时调用扭蛋机提供的方法即可，抽奖的实现不需要玩家类关系，扭蛋机的改动也不会影响到玩家的调用。</p><hr><p>迪米特法则其实是两方面的，一来依赖者只依赖值得依赖的，二来被依赖者只暴露需要暴露的。上面的例子介绍的其实是第二方面的内容。关于第一方面，在上例中可以理解为玩家抽奖不应该直接与奖品类关联，这会导致关系复杂，耦合度过高。而是通过扭蛋机的方式，玩家只依赖扭蛋机的抽奖功能，而奖品类则将信息提供给扭蛋机，从而将玩家和奖品分隔开来降低耦合。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单攀爬系统实现</title>
      <link href="/posts/43756/"/>
      <url>/posts/43756/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本文主要总结UE4制作攀爬系统的主要过程，参考教程<a href="https://www.bilibili.com/video/BV1yb4y1o7BY">【永昼UE】【技の屋】进阶攀爬系统（UE5示例）</a>，运动系统的额外知识会另开专题</p></blockquote><h2 id="准备工作">准备工作</h2><h3 id="从第三人称模板新建项目">从第三人称模板新建项目</h3><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/093247.png" alt="第三人称模板"></p><h3 id="删掉多余的部分">删掉多余的部分</h3><h4 id="删除多余输入映射">删除多余输入映射</h4><p>在项目设置中删除VR输入和移动端输入映射</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/092422.png" alt="更改项目设置"></p><h4 id="删除多余蓝图">删除多余蓝图</h4><p>在角色蓝图中删除VR输入和移动端输入</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/100348.gif" alt="删除多余蓝图"></p><h4 id="删除并调整地图">删除并调整地图</h4><p>使用第三人称提供的默认地图，删掉多余的墙壁和平台，调大地图，创建几个几何体用来攀爬测试。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/105656.png" alt="调整第三人称的地图"></p><h3 id="导入资源">导入资源</h3><p>下载<a href="https://wwi.lanzoup.com/ifzYo04qn4jc">动画素材资源</a>并导入项目，注意需要绑定骨骼。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/105436.png" alt="导入动画资源"></p><h3 id="修改默认设置">修改默认设置</h3><h4 id="设置飞行模式">设置飞行模式</h4><p>打开角色蓝图，选中角色移动组件，在右侧的细节面板输入&quot;fly&quot;找到飞行相关的设置。</p><p>攀爬实际上是利用角色移动模式的飞行模式实现的，设置“制动降速飞行”为2048，勾选“可飞行”选项。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/103440.png" alt="设置飞行模式"></p><h4 id="设置根运动">设置根运动</h4><p>动画资源中有一些使用了根运动，在内容面板选中动画资源中后缀为“RM”的几个动画序列，右键选择“资产操作”-&gt;“通过属性矩阵进行批量编辑”打开属性矩阵。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/111038.png" alt="选中动画序列右键"></p><p>在右侧的面板中展开“RootMotion”选项，勾选“启用根运动”。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/111234.png" alt="启用根运动"></p><h2 id="正式开始">正式开始</h2><h3 id="设置攀爬的动作">设置攀爬的动作</h3><h4 id="创建动画混合空间">创建动画混合空间</h4><p>在动画目录下创建一个动画混合空间并打开</p><p>再左侧的“资产详情”面板设置横纵轴。水平坐标命名为“deriction”，最小最大轴值分别设为-180和180，网格分区设为8。垂直坐标命名为”climb speed“，最小最大轴值分别设为0和200，网格分区设为4。</p><p>水平坐标表示攀爬的移动方向，通过-180到180的浮点数来表示，分区为8表示8个方向。垂直坐标表示攀爬的速度</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/111757.png" alt=""></p><p>在打开右下角的资产浏览器，将对应的动画序列拖入坐标轴并保存。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/151053.png" alt="放置好的动画序列"></p><h4 id="添加状态切换">添加状态切换</h4><p>状态切换在动画蓝图中写。打开动画蓝图，进入默认的状态机里的”Idle/Run“状态，这个预先写好的状态是用于从静止到奔跑的转换，使用的是混合空间1D</p><blockquote><p>没有加1D的混合空间是二维的，接收两个坐标轴上的坐标输入，1D只有一个坐标轴</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/151839.png" alt="Idel/Run状态"></p><p>为了简单起见，我们就把攀爬的状态写在这里。</p><p>添加一个混合空间节点，注意是自己之前建的那个攀爬的混合空间。其接受两个浮点型输入（即上文的横纵坐标）并输出一个状态</p><p>由于每个状态只有一个状态可以输出，而混合空间（无论是1D还是2D）均会返回状态，故需要使用混合列表判断输出的是哪个状态。</p><p>添加一个根据布尔值的混合列表，其接受两个状态输入分别为”真状态“和“假状态”，当布尔值为真时，输出“真状态”，当布尔值为假时，输出“假状态”。</p><p>新建一个布尔值类型的变量，命名为”is Climbing“表示玩家是否处于攀爬状态。将&quot;is Climbing&quot;连至混合列表的布尔值判断，攀爬混合空间的状态连至“真状态”，奔跑混合空间的状态连至“假状态”，混合列表的输出连至最后的输出状态。</p><p>新建一个浮点型变量，命名为“Direction“，表示攀爬时移动的方向。将对应的变量连至攀爬混合空间的输入。</p><p>此时攀爬的基本运动的动画部分就解决了，后续会通过蓝图接口传递“is Climbing&quot;和”Direction&quot;两个变量。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/153701.png" alt=""></p><p><a id="INT"></a></p><h4 id="创建蓝图接口">创建蓝图接口</h4><p>创建一个蓝图接口，命名为BPI_Anim，这个蓝图接口就是沟通角色蓝图和动画蓝图的工具，在蓝图接口中新建两个函数，一个函数命名为INT_Direction，添加一个浮点型输入参数Direction，另一个命名为INT_ChangeClimbingPoseture，添加一个布尔型输入参数is_Climbing，对应上文。</p><h3 id="实现攀爬的逻辑">实现攀爬的逻辑</h3><p><a id="coordinate"></a></p><h4 id="坐标系">坐标系</h4><p>在实现攀爬之前，我们需要先确定一件事，就是攀爬状态下坐标系的变化。正常情况下，角色站立在地面上，受到重力的作用，其反方向就是角色的上方，角色面朝的方向就是角色的前方，而UE4是左手坐标系，将四指从上方握到前方，大拇指指向的方向就是角色的右方。而在攀爬状态下，角色应该是贴合在攀爬面上的，这也就导致了角色攀爬时的坐标系和正常情况下的坐标系并不相同。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/162408.png" alt="攀爬时的坐标系"></p><p>以上图为例，这面墙是倾斜的，那么角色攀爬在这个墙上时，依然需要贴着墙壁，那么此时角色的坐标系其实是跟墙面的法线有关的。墙面的法线方向的反方向是角色的前方，平行于墙面斜向上的方向是角色的上方，同样根据左手系可以确定右方。</p><p>在正常情况下，角色接收向前的输入开始前进后退，接收向右的输入开始左右移动，那么在攀爬时，就需要根据攀爬时的坐标系重新确定，接收前的输入开始上下移动，接收向右的输入开始左右移动。</p><p>这一点需要通过改变蓝图中预置的MovementInput来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/16/103009.png" alt="MovementInput"></p><p>如上图所示，新建两个变量ClimbingUpDirection和ClimbingRightDirection。在输入后加一个判断，如果处于攀爬状态，则输入的方向由这两个变量来控制。</p><p><a id="FindClimbingRotation"></a></p><h4 id="确定攀爬方向">确定攀爬方向</h4><p>综上所述，在攀爬时需要首先确定的就是攀爬的方向。在角色蓝图中新建一个函数，命名为FindClimbingRotation，同时新建两个向量变量，分别叫ObstacleLocation和ObstacleEndLocation。</p><p>在函数中，使用ObstacleEndLocation减去ObstacleLocation，得到一个新的向量，将其标准化，显而易见这得到的就是向上的方向，再新建一个ObstacleNormal，在函数中将其反向，再标准化，这得到的就是向前的方向，通过向前的方向和向上的方向做叉积，再标准化，就会得到向右的方向。将向上的方向和向右的方向分别设置变量ClimbingUpDirection和ClimbingRightDirection存储起来，并且将三个单位化（标准化）的向量通过&quot;Make Rotation from Axes“结点创建Rotation并存储为Climbing Rotation。</p><p>上面用到的ObstacleLocation，ObstacleEndLocation，ObstacleNormal是后面射线检测时得到并存储的，这里只需要当做已知值使用即可。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/101803.png" alt="确定攀爬方向"></p><h4 id="Tick处理">Tick处理</h4><p>由于攀爬和正常行走是同一级别的运动，所以需要通过tick来判断当前的运动状态，如果是在攀爬状态，则需确定攀爬方向便于移动，同时添加一个do once结点，开始时关闭，当处于攀爬状态且确定完攀爬方向时将do once重置，退出攀爬状态后执行do once退出攀爬状态。</p><p>另一方面，如何确定攀爬状态？这就是需要在tick中处理的另一个部分了，这个部分也是攀爬系统的主要处理部分。在tick中我们使用sequence结点将该处理置于判断运动状态之后。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/142118.png" alt="tick处理"></p><h4 id="Climbing-Tick">Climbing Tick</h4><p>这里实现上文中的tick中需要用到的攀爬系统的主要处理过程。</p><p>新建一个自定义事件，命名为Climbing Tick，并在tick处理后的sequence的Then 1中调用，如上图所示。</p><p><a id="NotClimbableActors"></a></p><p>游戏中肯定存在一些墙体和障碍物是可以攀爬，另一些则不可攀爬。在进行攀爬处理之前，需要将这些不可攀爬的Actor放到一起存储起来，新建一个Actor的数组，命名为NotClimbableActors。为简单起见，这里调用引擎提供的方法Get All Actors with Tag，将Tag设为 Not Climbable，并将返回值设置为NotClimbableActors。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/205659.png" alt="NotClimbableActors"></p><blockquote><p>官方文档中建议不要在Tick中使用该方法，这里只是简单起见。实际中请使用通道检测等其他方法。</p></blockquote><p>之后判断一下是否在攀爬状态，这里判断的目的是区分出正常移动状态和攀爬时的状态。在正常移动情况下，需要确定是否要进入攀爬状态，在攀爬状态情况下，由于地形可能有起伏，需要时刻确定当前的旋转和方向。这里只需要找到上文<a href="#FindClimbingRotation">FindClimbingRotation</a>中需要的ObstacleLocation，ObstacleEndLocation，ObstacleNormal三个变量存储起来即可。另外攀爬状态时可能会提前掉落或是登顶，这些都需要考虑。</p><p>先来看简单的正常运动状态的逻辑</p><h5 id="正常运动进入攀爬状态">正常运动进入攀爬状态</h5><p>首先进行速度的限制，如果速度过小则不主动进入攀爬状态。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/205621.png" alt="速度过小不主动进入攀爬"></p><p>进行射线检测，这里连线比较乱，所以新建了一个函数命名为ObstacleDetection，输入三个浮点数，分别表示速度标度，最短检测距离和最长检测距离。</p><p><a id="FirstDetection_Running"></a></p><p>获得角色的速度向量，将其标准化获得速度方向，同时获取速度大小并将速度大小按照速度标度在最短检测距离和最长检测距离中插值，获得实际检测距离。实际检测距离乘以速度方向即可得到检测射线。获得角色位置，将角色位置做为起点，角色位置加上检测射线作为终点进行通道射线检测。通道射线检测中忽略掉存储的<a href="#NotClimbableActors">NotClimbableActors</a>，之后将命中结果，命中的位置和命中的法线输出。</p><p>若命中，则将命中位置保存为ObstacleLocation，命中法线保存为ObstacleNormal，未命中则不做处理。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/205522.png" alt="ObstacleDetection_Running"></p><p>有了命中位置还不够，如果只是小土坡很有可能也会检测到，但大台阶小土坡显然无法进行攀爬，因为它们不够陡峭，所以还要判断障碍物是否足够陡峭。这个比较简单，将前面输出的法线在纵坐标上减1，再判断新的向量的模是否大于一即可，这个可以通过一个简单的图来表示。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/205334.png" alt="图示判断墙面是否陡峭"></p><p>如果障碍物不够陡峭则不进行后续操作，如果足够陡峭，则进行第二次检测。别忘了，第一次检测得到了ObstacleLocation和ObstacleNormal还有ObstacleEndLocation没有获得，这也是第二次检测的目的。当然这里还有另一层含义，ObstacleLocation到ObstacleEndLocation的距离大体上可以看做障碍物的高度，如果障碍物不够高，比如还没角色高，那么此时需要进行的是翻越或者跨过等动作而不是攀爬。</p><p>第二次检测射线的起点位置仍然是角色位置，终点位置需要我们计算一下，这里创建了一个纯函数。纯函数意味着这个函数只通过计算等处理即可完成，不需要执行，类似一个公式一样。纯函数的内容如下，主要思想是将角色的向前向量（同之前一样）向上旋转45°，乘以距离加上起点位置就能得到终点位置。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/205441.png" alt="计算第二次检测的终点位置"></p><p>第二次检测后将检测结果和命中位置返回。未命中不作处理，命中则保存命中位置为ObstacleEndLocation。</p><p><a id="ChangeMoveModetoClimb"></a></p><p>若第二次命中，则说明前方有障碍物且可攀爬，主动进入攀爬状态，设置isClimbing为True。另外，前面提到过攀爬状态实质上是飞行模式，调用引擎提供的SetMovementMode方法，设置运动状态为飞行。接着，设置最大飞行速度，也就是攀爬状态的速度，另外调用setOrientRotationtoMovetment方法，修改OrientRotationMovement属性为false。再然后调用之前创建的<a href="#INT">INT_ChangeClimbingPosture</a>接口函数，将is_Climbing传递给动画蓝图，方便调整动画状态。这些流程我将其放入函数ChangeMoveModetoClimb中，便于整理和使用。其实转换到攀爬状态还需要调整两个设置，这个放到下面来说。</p><blockquote><p>简单说明下OrientRotationtoMovement是角色移动组件中的一个属性，其为true则表示当有移动输入时，移动方向会转向旋转的输入方向，即静止不动时，转动鼠标时角色无反应，但在移动过程中，转动鼠标，角色会朝向鼠标输入的旋转方向移动，在攀爬过程中，这个属性不需要，故将其设为false。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/15/213324.png" alt="ChangeMoveModetoClimb"></p><p>在进入攀爬状态的最后，为了让效果更加流畅，加入了一个跳跃上墙的动作，这里自然是用蒙太奇来实现的。将预置的跳跃动画创建蒙太奇，此时蒙太奇的插槽为默认插槽。</p><p>为了让蒙太奇可以播放，将动画蓝图的状态机的默认状态机后添加一个默认的插槽。</p><p>接着转回角色蓝图，添加一个新事件JumptoClimb，在SetMovementMode之后调用。JumptoClimb事件中先播放蒙太奇，接着将角色的旋转调整为计算出的旋转，对，就是那个在<a href="#FindClimbingRotation">FindClimbingRotation</a>中计算出的旋转。</p><h5 id="攀爬状态中的处理">攀爬状态中的处理</h5><p>先来说大体逻辑，攀爬状态中的处理与正常状态进入攀爬状态一样，都是需要两次检测，但检测的目的并不完全一致，这个稍后细说。两次检测都成功则同样记录那三个变量ObstacleLocation，ObstacleEndLocation，ObstacleNormal然后进行一些处理，任意检测不成功就要转换到正常状态。</p><p>第一次检测，同样是起点角色位置，终点角色位置+一段向前的向量，不过这次不需要速度的判断，向前向量设置为定长即可，将命中结果，命中位置和法线输出。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/16/091952.png" alt="ObstacleDetection_Climbing"></p><p>这里有一个小技巧，ObstacleNormal，也就是法线方向，在<a href="#FirstDetection_Running">正常状态下第一次检测</a>到就直接存储了，因为只需要一次值即可。而在攀爬状态中如果持续运动，会持续产生法线，而攀爬过程中可能会受到地形起伏的影响，故可以利用插值的方式使得地形起伏的变化过渡地更加自然。这里使用了VInterp to Constant结点，将上个ObstacleNormal当做Current，新检测到的ObstacleNormal当做target，通过每次tick的时间进行插值，结果保存到ObstacleNormal用于下次的插值。</p><blockquote><p>VInterp to Constant是UE4众多插值结点中的一个，V表示插值的数据是向量，Interp to就是插值的意思，Constant表示插值是线性的，不加Constant则表示非线性，起点和终点的过渡会比较平滑。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/16/093056.png" alt="VInterp to Constant"></p><p>第一次检测不成功则说明没有地方可以攀爬了，转换为正常状态即可，这个部分放到后面写。</p><p>第一次检测完后进行第二次检测，同样是要判断障碍物是否够高，够高才能继续攀爬，不够高说明爬到顶部应该登陆了。与正常状态下的第二次检测时一样的，输出命中结果和位置，存储命中的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/16/094457.png" alt="SecondDetection_Climbing"></p><p>如果第二次检测命中，则应当继续攀爬，此时需要进行一些设置。首先是攀爬方向，需要在动画蓝图中调用。这里使用RotationFromXVector，从X方向创建一个旋转值。</p><p>这里打断一下，可能前面的一些铺垫操作你有些模糊了，前面实现攀爬逻辑中一开始我们就对<a href="#coordinate">攀爬时的坐标系</a>进行了调整，将那张图再放一下</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/13/162408.png" alt="攀爬时的坐标系"></p><p>RotationFromXVector结点的意思是rotation会跟随XVector，这就导致XVector是常量的roll是无效的，而pitch和yaw是有效的。这里将输入的Vector和输出的rotation均拆分开，将GetMoveForward和GetMoveRight分别传入XVector和YVector，此时蓝色的向量其实是XVector，红色的向量其实是YVector，再将ZVector设为0，则只会产生XVector和YVector的变化，这其实就是一个yaw旋转。</p><p>拆分开的rotation将有效的yaw设置为ClimbingRotation，攀爬时的方向就确定好了。接着调用之前创建的<a href="#INT">INT_Direction</a>接口函数，将ClimbingRotation传递给动画蓝图，随后设置角色的旋转为<a href="#FindClimbingRotation">FindClimbingRotation</a>计算出的Rotation。</p><p>最后，给角色移动组件加一个压向障碍物的力，这个力的作用是让角色能够紧贴障碍物。正常状态下，角色受重力影响会一直贴在地面上行走，但攀爬状态（实质上是飞行模式）不受重力这样的外力影响，如果遇到起伏的地形，很有可能会产生角色浮空的现象，可以从下图直观看到。</p><p><img src="https://s1.ax1x.com/2022/05/16/OhC8US.gif" alt="这图压了好久，凑活看吧"></p><p>虽然tick一直在计算Rotation但角色实际上还是一段一段线段在运动，导致朝向障碍物的距离（图中粉紫色的线，其实是检测射线）越来越大。最直接的办法就是给角色一个外力，让角色能够一直保持紧贴障碍物。</p><p>以上这些操作我也将他们放到了一个函数中让蓝图更整洁，具体如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/16/211810.png" alt="ClimbingSetting"></p><p>两次检测都成功的处理介绍完了，那失败的呢？两次检测失败的情况是不一样的，先来说第二次检测未命中的情况：</p><p>第二次检测未命中说明障碍物不够高了，也就是说当前角色仍然在障碍物上，不过马上就要越过障碍物了，那么此时的处理就是让角色登陆。</p><p>登陆要分几步来处理。首先是检查是否有足够的空间来登陆，这里使用胶囊体检测来实现，胶囊体检测和射线检测类似，只不过起点和终点都是胶囊体，中间仍是一条线段，当线段或者胶囊体产生命中Hit Result就会为真。具体如下，新建一个函数CheckSpaceforLanding，在函数中首先获得角色位置和向前向量，角色位置向上平移一段距离Height作为起点位置，起点位置向前一段距离Distance作为终点距离调用胶囊体检测。这里的Height和Distance我作为了函数传入的参数。最后输出胶囊体检测的命中结果和终点位置。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/17/084929.png" alt="胶囊体检测"></p><p>胶囊体的半高默认是96，要想角色可以登陆则至少起点位置应在角色位置上方192的位置，考虑到此时胶囊体并不是完全在障碍物的上沿，那么这个距离还应更大一点，这里我设置的是200，即Height为200。然后就是向前的距离Distance，这个距离是用来判断是否有地方让角色登陆，后续检测也会用到。这个变量不能太大，太大会让角色登陆后向前位移很多，也不能太小，太小很有可能角色登陆后站不下就又掉下来了，这里我设置的是50。</p><p>跟前面的检测不同，这次的检测只有未命中才说明有足够的位置让角色登陆，这也是为什么需要终点位置。当检测出现命中时，说明要么空间太狭窄，要么登陆的路径上仍然有阻挡（这两种情况地形都很奇怪）而无法登陆。当然此时角色仍然在攀爬状态，可以选择让角色继续留在原地不进行任何操作，也可以像我一样，直接让角色退出攀爬状态。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/17/085054.png" alt="CheckSpaceforLanding"></p><p>紧接着是第二次检测，主要目的是找到角色的落脚点，故直接用刚刚得到的终点位置做起点，将他再向下Height距离的位置作为终点进行射线检测，如果成功命中则说明此时角色是可以登上去的，而未命中则说明这个障碍太薄了。检测结束后输出命中结果和命中位置。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/17/092525.png" alt="登陆第二次检测"></p><p>如果角色可以登陆，那么接下来有这么几个操作：</p><ul><li>播放登陆的蒙太奇</li><li>将角色位置移动到登陆的位置</li><li>改变角色的运动状态和其他细节调整</li></ul><p>首先是最简单的蒙太奇，直接在动画序列中找到登陆的那个动画序列创建蒙太奇，再在蓝图这里调用即可。</p><p>然后是将角色位置移动到登陆的位置，使用MoveComponentTo结点。上面的检测得到了命中位置，要注意这个位置不是登陆的位置。MoveComponentTo传入的目标位置是胶囊体中心的位置，所以应该将命中位置Z坐标增加一个半高96再传入。</p><p>最后是改变运动状态和其他细节的调整。改变运动状态这里类似前面的<a href="#ChangeMoveModetoClimb">ChangeMoveModetoClimb</a>，创建一个函数命名为ChangeMoveModetoWalk，里面的结点不变，不过要将一些属性反一下。设置isClimbing为假，设置MovementMode为行走，设置OrientRotationtoMovement为真，最后调用<a href="#INT">接口函数</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/17/094306.png" alt="ChangeMoveModetoWalk"></p><p>光改变运动状态是不够的，如果角色由一个斜面的障碍物登顶，还需要更改旋转使得登陆后能恢复到直立状态。这里使用的是通过时间轴对旋转进行插值。创建一个时间轴，长度为0.2，0处打关键帧值为0，1处打关键帧值为1。关键帧插值设为自动使过渡更平滑。由于需要角色由原来的旋转过渡到直立，故需要roll和pitch均过渡到0，而yaw不变。添加一个Rotator的lerp结点，获得角色的旋转赋与A，再获得角色的旋转的yaw值赋予B，roll和ptich均默认为0，Alpha则为时间轴输出的参数。新建一个SetActorRotation的结点，将插值的结果作为NewRotation传入即可。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/17/101338.png" alt="调整旋转"></p><p>上图中除了改变运动状态和调整旋转外还有一个自定义事件EndClimbing，前文中检测失败（登陆的第一次检测是成功）退出攀爬状态都是直接调用这个事件。</p><h5 id="控制结构">控制结构</h5><p>正常运动进入攀爬状态和攀爬状态中的处理都写完了，在此之前，还需要一个控制结构来控制什么时候进行哪种情况的处理。最基本的就是判断是否在攀爬状态，如果是则进行攀爬中的处理，不是则进行正常运动的处理。注意，一旦正常运动进入攀爬状态，则正常运动的处理就不应该再进行了，等到开始进行攀爬中的处理时，再重置正常运动的处理使得攀爬结束后可以重新进行正常运动到攀爬的转换。</p><p>另外，攀爬中的处理使用了一个门来控制，在正常运动进入攀爬状态的最后打开，在退出攀爬运动时关闭。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/17/102416.png" alt="控制结构"></p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
            <tag> 蓝图 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不溺于暖阳，不惧于狂风</title>
      <link href="/posts/25302/"/>
      <url>/posts/25302/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="B站的青年节视频">B站的青年节视频</h2><p>虽然不愿承认，但，我的五四青年节确实是从B站开始的。</p><p>早上起床洗漱后我就下意识地打开了B站，准备先刷几个视频再去做安排的事情，映入眼帘的，自然是B站的横幅推广--<a href="https://www.bilibili.com/video/BV1A44y1u7PF">《不被大风吹倒》：莫言写给青年朋友的一封信</a>。哦，又到青年节了。看完了这条视频后我首先想到的，不是折服于莫言先生对于疾风袭来时的精妙描述，也不是对于劲草对抗狂风的顽强精神的感动，而是一段来自2020年的回忆。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/04/211547.png" alt="2022年B站五四视频"></p><p>在2020年的这个时候，B站通过官方号发布了第一次的五四视频--<a href="https://www.bilibili.com/video/BV1FV411d7u7">bilibili献给新一代的演讲《后浪》</a>。这个视频在当时引起了不少的争论，对比今天的五四视频，我个人仍然认为《后浪》，就好比我高中时写过那些的作文一样，是一条不怎么真诚的演讲视频。</p><p>当然，我知道B站完全有理由和资格在那一年发布那样一条视频。时间再往前倒那么几年，彼时的B站，还只是一个粉丝自制的“小破站”，在2014年陈睿退出上市的猎豹移动正式加入B站后担任董事长之后，B站陆续完成了多次融资，获得了资本看好后的B站开始快速发展，逐渐成为国内视频创作平台的“顶流”，之后到了2018年，B站在美国挂牌上市，正式完成商业化。商业化后的B站更需要营收和用户体验的权衡，那时的B站还算克制，在会员权益上并没有弱化普通用户的体验，而是着力在其他业务盈利（游戏，直播，线下活动等）。再后来的2019年，伴随着一场名为“2019最美的夜”的晚会，B站开始了正式“出圈”，吸引了大量的博主明星入驻，B站的知名度大大提升。于是2020年的青年节视频，站在浪头的B站自然有能力去发布《后浪》，与其说是演讲，不如看做是B站的一次商业宣传展示罢了。那些虚无缥缈的对青年的吹捧，不过只是商业的表演。</p><h2 id="Z世代？">Z世代？</h2><p>Z世代广义上是对00后的泛称，也是B站的主要用户群体，当然我也是刚知道的，不过是一个称呼而已。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/04/223937.png" alt="Z世代"></p><p>我记得在我初高中的时候，对00后的刻板印象就已经开始了。继承于千禧一代的评价，“一代不如一代”的标签开始贴在Z世代身上。与此同时，“蜜罐下成长”，“沉迷于网络游戏”等刻板印象纷至沓来。在长辈眼中，Z世代就是伴随着中国的快速发展；学校和社会的保护；科技产品的便捷成长起来的，没有经受过他们经历过的苦难。我一直认为这种想法是根本上的错误。这种想法实质上是认为年轻一代应该生活在更加艰难的环境下，就像长辈们一样才能真正成长，那么也就是说长辈们拼搏出的社会发展是错误的，顺推下去，社会发展本身就是错误的，这不就是狭隘的固步自封的思想吗？这种想法毫无逻辑可言。</p><p>其实Z世代确实在年轻时没有像长辈一样经历十分艰难的生活环境，但这也并不表明Z世代只会沉浸于享受与娱乐的暖阳之中。Z世代同每一代一样，理所应当地接受时代带给自己的便捷与自在，也理所应当地承担为下一个时代贡献力量的责任。在网络上休闲娱乐的同时，也学习先进的技术和思想。</p><h2 id="不被大风吹倒">不被大风吹倒</h2><p>青年的生活中，并不是只有享受与娱乐的暖阳，更有挑战与困难的狂风。新冠疫情，内卷与躺平，国际形势变化，一言难尽的网络环境…这些都在真真切切的影响着青年的生活。</p><p>但那又如何呢，这些不过是同我们的长辈一样在成长的过程中遇到的由于各种因素产生的艰难时刻罢了，难道莫言先生小时候辍学放牛割草只能靠《新华字典》识字就比不上我们遇到的这些困难了吗？</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/05/04/231120.png" alt="放牛割草，十分孤独"></p><p>正如这条视频中提到的，人生中有很多艰难的时刻，它们就像是莫言先生和他爷爷遇到的那次狂风一样，即使车里的草被刮得只剩一棵，车子不能前进一步，也要坚持在原地，不被大风吹倒。车子不能前进只是暂时的，风停之后依然可以前行。</p><blockquote><p>不溺于暖阳，不惧于狂风，这才是青年</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 态度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 青年 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模板(一) 函数模板和类模板</title>
      <link href="/posts/27145/"/>
      <url>/posts/27145/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="泛型编程">泛型编程</h2><blockquote><p>模板是泛型编程的一种重要思想，STL(Standard Template Library，标准模板库)是采用模板实现的一个实例</p></blockquote><h2 id="函数模板">函数模板</h2><h3 id="函数模板的定义">函数模板的定义</h3><h4 id="普通模板函数">普通模板函数</h4><p>如果我有一个交换int变量的函数，那么它可以有如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; <span class="comment">// 20 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我又有一个交换double变量的函数，那么它可以有如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">10.0</span>, b = <span class="number">20.0</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; <span class="comment">// 20.0 10.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个函数除了变量的类型不同外，语句的格式和逻辑都是一样的。那么我们就可以通过函数模板，定义一个与变量类型无关的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">templete&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//class 也可以换成 typename</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>, b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">myswap</span>(a, b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b; <span class="comment">// b a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员模板函数">成员模板函数</h4><p>成员函数也可定义为模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">myParameter</span><span class="params">(T t)</span></span>&#123;cout&lt;&lt;<span class="built_in">typeid</span>(t).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass me;</span><br><span class="line">    me.<span class="built_in">myParameter</span>(<span class="number">10</span>); <span class="comment">// i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一点：<span style="background:#FF9999;">使用函数模板的成员函数不能为虚函数</span></p><p>这是由于编译器在解析一个类时就需要确定其vtable的大小，而模板函数需要根据实参才进行实例化，则如果需要确定vtable的大小就需要扫描整个代码确定实参类型，这显然是不能做到的。</p><h3 id="函数模板的使用">函数模板的使用</h3><h4 id="基础使用">基础使用</h4><p>在上面的定义中其实已经看到过一些使用的方法了。函数模板定义本身不参与编译，只有当使用函数模板并提供实参时才会进行根据提供的参数类型进行编译，这一过程被称为模板的实例化。</p><p>在使用时函数模板会根据用户提供的参数类型进行实例化，对函数模板的使用可以通过如下方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> da = <span class="number">10.5</span>, db = <span class="number">20.5</span>;</span><br><span class="line">    <span class="type">char</span> ca = <span class="string">&#x27;a&#x27;</span>, cb = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myswap</span>(da, db); <span class="comment">// 根据实参类型自动推导</span></span><br><span class="line">    cout&lt;&lt;da&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;db&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">myswap</span>&lt;<span class="type">char</span>&gt;(ca, cb); <span class="comment">// 显式告诉模板类型</span></span><br><span class="line">    cout&lt;&lt;ca&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cb&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板必须确定出正确的类型才能使用，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数模板，但实际函数中并未用到模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;I&#x27;m myout()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// myout(); 报错，编译器没有推导出T的类型</span></span><br><span class="line">    <span class="built_in">myout</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;(); <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">myout</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板函数和普通函数调用规则">模板函数和普通函数调用规则</h4><p>如果模板函数和普通函数都有实现，则他们的调用规则如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;from templete function&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;from normal function&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> ia = <span class="number">100</span>, ib = <span class="number">200</span>;</span><br><span class="line">    <span class="type">char</span> ca = <span class="string">&#x27;a&#x27;</span>, cb = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果参数类型能够匹配对应的普通函数，则调用普通函数</span></span><br><span class="line">    <span class="built_in">myswap</span>(a, b); <span class="comment">// from normal function</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果参数类型不能匹配普通函数，则调用模板函数</span></span><br><span class="line">    <span class="built_in">myswap</span>(ca, cb); <span class="comment">// from templete function </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以通过空模板参数列表强制调用模板函数</span></span><br><span class="line">    myswap&lt;&gt;(ia, ib); <span class="comment">// from templete function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板函数重载">模板函数重载</h4><p>模板函数可以进行重载，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b, T&amp; c)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">    c = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> ia = <span class="number">100</span>, ib = <span class="number">200</span>, ic = <span class="number">300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myswap</span>(a, b); <span class="comment">// 调用myswap(T&amp; a, T&amp; b);</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl; <span class="comment">// 20 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myswap</span>(ia, ib, ic); <span class="comment">// 调用myswap(T&amp; a, T&amp; b, T&amp; c);</span></span><br><span class="line">    cout&lt;&lt;ia&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ib&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ic&lt;&lt;endl; <span class="comment">// 200 300 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板函数特化">模板函数特化</h4><p>模板函数特化是说有时通用的函数模板不能解决个别类型的问题，我们必须对此进行定制，这就是函数模板的特化。</p><p>函数模板的特化必须把所有的模版参数全部指定，<a href="#classTemplate">类模板</a>中也有相应用法。</p><p>需要注意的是特化函数和原函数返回值类型需相同，模板函数的返回值也是参数同样需要使得推导或指定的返回值类型相同，关于模板函数的返回值详见<a href="#returnValueOfTemplateFunction">下一小节</a></p><p>举一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Animal</span>(string animalClass, <span class="type">int</span> animalAge)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_class = animalClass;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_age = animalAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getClass</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_class;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeClass</span><span class="params">(string s)</span></span>&#123;<span class="keyword">this</span>-&gt;_class = s;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeAge</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">this</span>-&gt;_age = i;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    string _class;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化函数模板，支持Animal类的交换</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(Animal&amp; Aa, Animal&amp; Ab)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tempClass = Aa.<span class="built_in">getClass</span>();</span><br><span class="line">    Aa.<span class="built_in">changeClass</span>(Ab.<span class="built_in">getClass</span>());</span><br><span class="line">    Ab.<span class="built_in">changeClass</span>(tempClass);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> tempAge = Aa.<span class="built_in">getAge</span>();</span><br><span class="line">    Aa.<span class="built_in">changeAge</span>(Ab.<span class="built_in">getAge</span>());</span><br><span class="line">    Ab.<span class="built_in">changeAge</span>(tempAge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    myswap&lt;&gt;(a, b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Animal <span class="title">tiger</span><span class="params">(<span class="string">&quot;tiger&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Animal <span class="title">cat</span><span class="params">(<span class="string">&quot;cat&quot;</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">myswap</span>(tiger, cat);</span><br><span class="line">    cout&lt;&lt;tiger.<span class="built_in">getClass</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tiger.<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="returnValueOfTemplateFunction"></a></p><h4 id="模板函数的返回值也是参数">模板函数的返回值也是参数</h4><p>当模板函数的返回值是另一个模板参数时，无法通过具体的实参类型来判定，此时有两种解决方案：</p><ul><li>通过显式指定返回值类型，其他类型交由自动推导</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">mysum</span><span class="params">(T2 t2, T3 t3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T1&gt;(t2 + t3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = <span class="built_in">mysum</span>&lt;<span class="type">long</span>&gt;(<span class="number">1L</span>+<span class="number">20</span>); <span class="comment">// 显式指定T1类型，T2和T3由编译器推导</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例情况需要将返回值定为第一个模板参数类型，若其不为第一个则有以下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keyword">class</span> T3&gt;</span></span><br><span class="line"><span class="function">T3 <span class="title">mysum</span><span class="params">(T1 t1, T2 t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T3&gt;(t1 + t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// auto t3 = mysum&lt;long&gt;(1L + 20); 报错，无法指定T3的类型</span></span><br><span class="line">    <span class="keyword">auto</span> t3 = <span class="built_in">mysum</span>&lt;<span class="type">long</span>, <span class="type">int</span>, <span class="type">float</span>&gt;(<span class="number">1L</span> + <span class="number">20</span>); <span class="comment">// 正确，T3为long类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这说明显式指定需要按顺序从左到右依次指定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过尾置返回类型从参数类型中获取</li></ul><p>这个情况是当形参类型中有包含返回值类型时用尾置返回类型的方法去获得：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myfindzero</span><span class="params">(T1 begin, T1 end)</span> -&gt; <span class="title">decltype</span><span class="params">(begin)</span></span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(begin) it;</span><br><span class="line">    <span class="keyword">for</span>(it = begin; it != end; it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == <span class="number">0</span>) <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">myfindzero</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) != vec.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;find zero&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;non zero&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find zero</span></span><br></pre></td></tr></table></figure><p>尾置返回类型是在<code>C++11</code>标准中新增的语法，可以用于任何函数定义中，旨在方便复杂函数的定义。尾置返回类型跟在形参列表后面并以一个<code>-&gt;</code>符号开头。为了表示函数真正的返回类型跟在形参列表之后，需要在本应该出现返回类型的地方放置一个<code>auto</code>关键字。</p><p>尾置返回类型通常使用decltype()方法配合auto追踪返回值的类型，这也是decltype的最大用途，其他decltype()的使用方法可见<span style="background:#FFDBBB;">melonstreet</span>的博客：<a href="https://www.cnblogs.com/QG-whz/p/4952980.html">C++11特性：decltype关键字</a></p><h2 id="类模板">类模板</h2><p>类模板和函数模板类似，类模板的作用是建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。</p><blockquote><p>类模板通常用来做容器或者动作的封装。</p></blockquote><h3 id="类模板的定义">类模板的定义</h3><h4 id="一般类模板定义">一般类模板定义</h4><p>定义一个动物类模板，负责存储和显示动物的相关信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类中用到了多少种不同类型的变量，就定义多少个模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ageType A_age;</span><br><span class="line">    speciesType A_species;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(ageType age, speciesType species)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_species = species;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selfIntroduction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I&#x27;m a &quot;</span>&lt;&lt;A_species&lt;&lt;<span class="string">&quot; and I&#x27;m &quot;</span>&lt;&lt;A_age&lt;&lt;<span class="string">&quot; years old.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Animal huge(10, &quot;tiger&quot;);</span></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">int</span>, string&gt; <span class="title">huge</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;tiger&quot;</span>)</span></span>;</span><br><span class="line">    huge.<span class="built_in">selfIntroduction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// I&#x27;m a tiger and I&#x27;m 10 years old.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与函数模板不同，类模板不能自动推断实例化。</p><p>所以只能显式指定类型参数使用<code>Animal &lt;int, string&gt; huge(10, &quot;tiger&quot;)</code>，而不能让编译器自行推断<code>Animal huge(10, &quot;tiger&quot;)</code>。</p><h4 id="类模板中的成员函数模板">类模板中的成员函数模板</h4><p>把类模板和函数模板结合，定义一个含有成员函数的模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ageType A_age;</span><br><span class="line">    speciesType A_species;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(ageType age, speciesType species)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_species = species;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selfIntroduction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I&#x27;m a &quot;</span>&lt;&lt;A_species&lt;&lt;<span class="string">&quot; and I&#x27;m &quot;</span>&lt;&lt;A_age&lt;&lt;<span class="string">&quot; years old.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Years&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">growingUp</span><span class="params">(Years years)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age += years;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Wow, I&#x27;m &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;A_age&lt;&lt;<span class="string">&quot; years old now.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Animal huge(10, &quot;tiger&quot;);</span></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">int</span>, string&gt; <span class="title">huge</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;tiger&quot;</span>)</span></span>;</span><br><span class="line">    huge.<span class="built_in">selfIntroduction</span>();</span><br><span class="line">    huge.<span class="built_in">growingUp</span>(<span class="number">5</span>); <span class="comment">// 自动推断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// I&#x27;m a tiger and I&#x27;m 10 years old.</span></span><br><span class="line">    <span class="comment">// Wow, I&#x27;m 15 years old now.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类外定义">类外定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ageType A_age;</span><br><span class="line">    speciesType A_species;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> ageType age, <span class="type">const</span> speciesType species);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selfIntroduction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I&#x27;m a &quot;</span>&lt;&lt;A_species&lt;&lt;<span class="string">&quot; and I&#x27;m &quot;</span>&lt;&lt;A_age&lt;&lt;<span class="string">&quot; years old.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Years&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">growingUp</span><span class="params">(Years years)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义构造函数，需要加上模板声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line">Animal&lt;ageType, speciesType&gt;::<span class="built_in">Animal</span>(<span class="type">const</span> ageType age, <span class="type">const</span> speciesType species)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;A_species = species;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义成员函数，加上两层模板声明，且顺序不能调换</span></span><br><span class="line"><span class="comment">// template&lt;typename Years&gt; 报错</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Years&gt;</span><br><span class="line"><span class="type">void</span> Animal&lt;ageType, speciesType&gt;::<span class="built_in">growingUp</span>(Years years)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;A_age += years;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Wow, I&#x27;m &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;A_age&lt;&lt;<span class="string">&quot; years old now.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Animal huge(10, &quot;tiger&quot;);</span></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">int</span>, string&gt; <span class="title">huge</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;tiger&quot;</span>)</span></span>;</span><br><span class="line">    huge.<span class="built_in">selfIntroduction</span>();</span><br><span class="line">    huge.<span class="built_in">growingUp</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// I&#x27;m a tiger and I&#x27;m 10 years old.</span></span><br><span class="line">    <span class="comment">// Wow, I&#x27;m 15 years old now.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板的使用">类模板的使用</h3><h4 id="类模板成员函数实例化">类模板成员函数实例化</h4><p>在类模板实例化时，并不是其每个成员函数都实例化了，只有当使用该成员函数的时候才会进行实例化。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ageType A_age;</span><br><span class="line">    speciesType A_species;</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> ageType age, <span class="type">const</span> speciesType species)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_species = species; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selfIntroduction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;A_age + A_species&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Years&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">growingUp</span><span class="params">(Years years)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age += years;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Wow, I&#x27;m &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;A_age&lt;&lt;<span class="string">&quot; years old now.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">int</span>, string&gt; <span class="title">huge</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;tiger&quot;</span>)</span></span>;</span><br><span class="line">    huge.<span class="built_in">growingUp</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// huge.selfIntroduction();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wow, I&#x27;m 15 years old now.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void selfIntroduction()</code>显然是错误的，但本程序正常编译运行，没有任何错误和警告。但当将<code>huge.selfIntroduction();</code>取消注释后，编译会立即报错。</p><p><a id="classTemplate"></a></p><h4 id="类模板的特化和偏特化">类模板的特化和偏特化</h4><p>特化看上去和重载类似，通过特化类模板来为特定的类型指定行为，类模板可以有多个特化或偏特化，实例化时会优先选择最适合的特化或偏特化进行实例化。具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ageType A_age;</span><br><span class="line">    speciesType A_species;</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> ageType&amp; age, <span class="type">const</span> speciesType&amp; species)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_species = species; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I&#x27;m a base class template.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 特化，模板参数完全特化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&lt;<span class="type">int</span>, string&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> A_age;</span><br><span class="line">    string A_species;</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> <span class="type">int</span>&amp; age, <span class="type">const</span> string&amp; species)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_species = species; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I&#x27;m a specialize class template.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ageType&gt; <span class="comment">// 偏特化，模板参数不完全特化(或类型受限)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&lt;ageType, string&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ageType A_age;</span><br><span class="line">    string A_species;</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> ageType&amp; age, <span class="type">const</span> string&amp; species)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_species = species; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I&#x27;m a partialSpecialization class template.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">int</span>, string&gt; <span class="title">huge</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;tiger&quot;</span>)</span></span>;</span><br><span class="line">    huge.<span class="built_in">info</span>(); <span class="comment">// I&#x27;m a specialize class template.</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">double</span>, string&gt; <span class="title">shamate</span><span class="params">(<span class="number">10.2</span>, <span class="string">&quot;martian&quot;</span>)</span></span>;</span><br><span class="line">    shamate.<span class="built_in">info</span>(); <span class="comment">// I&#x27;m a partialSpecialization class template.</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">double</span>, <span class="type">char</span>&gt; <span class="title">kenan</span><span class="params">(<span class="number">7.5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;</span><br><span class="line">    kenan.<span class="built_in">info</span>(); <span class="comment">// I&#x27;m a base class template.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板成员和成员函数的特化">类模板成员和成员函数的特化</h4><blockquote><p>未特化的成员函数需要在类中以inline方式实现，成员函数的特化需要在类外实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ageType, <span class="keyword">typename</span> speciesType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ageType A_age;</span><br><span class="line">    speciesType A_species;</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> ageType&amp; age, <span class="type">const</span> speciesType&amp; species)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;A_species = species; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I&#x27;m a base memberFunctionTemplate.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Animal&lt;<span class="type">double</span>,string&gt;::<span class="built_in">info</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;I&#x27;m a specialize memberFunctionTemplate.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">int</span>, string&gt; <span class="title">huge</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;tiger&quot;</span>)</span></span>;</span><br><span class="line">    huge.<span class="built_in">info</span>(); <span class="comment">// I&#x27;m a base memberFunctionTemplate.</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Animal&lt;<span class="type">double</span>, string&gt; <span class="title">shamate</span><span class="params">(<span class="number">10.2</span>, <span class="string">&quot;martian&quot;</span>)</span></span>;</span><br><span class="line">    shamate.<span class="built_in">info</span>(); <span class="comment">// I&#x27;m a specialize memberFunctionTemplate.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
            <tag> C++ 模板系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Z-library不完全使用指南</title>
      <link href="/posts/33634/"/>
      <url>/posts/33634/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天是2022年4月23日，第27个世界读书日（全称&quot;世界图书与版权日&quot;）。回想起来，除了技术书籍，我上一次出于兴趣阅读一本书还是半年之前，那是一本<span style="background:#FFDBBB;">赫尔曼·黑塞</span>的《漂泊的灵魂》。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/23/180920.png" alt="《漂泊的灵魂》"></p><center style="color:#404040">《漂泊的灵魂》</center><p>当时我是晚上在入睡之前，趴在床上，每天读一章或两章。书很短，没几天就读完了。这个读书的形式跟我高中时很像，但高中时晚上在宿舍看书更像是一种冒险，宿舍门外是不停巡逻的宿管和他手中的高功率强光手电筒，时不时从宿舍门外透过窗户扫射一遍来提醒你他还没睡。即使那样我也阅读了不少书籍，其中大部分是从同学那里借来的。我记得当时有一本<span style="background:#FFDBBB;">村上春树</span>的《奇鸟行状录》，书的内容至少对于那时的我来说并不能理解，但也不妨碍我想要去读。那本书比较厚，并不能很容易地笼罩在被子里，再加上难以理解书的内容，读起来可以说是比较艰难了。</p><p>当然现在我仍然可以像高中那样趴在床上再读一遍这本书，但不必那么艰难了。也许遇到晦涩的部分我仍然无法完全理解，但至少我可以不用拿着那本厚厚的书，拿出手机阅读下载完的电子书即可。</p><p>电子书很大程度上解决了有些书又厚又重，携带起来比较麻烦的问题。但当前互联网上的电子书平台比较杂乱，而且有些年代比较久远的书在网上很难找到电子书版本。这就不得不提到本文的主角Z-library了。</p><h2 id="Z-library的简单介绍">Z-library的简单介绍</h2><p>Z-library自称是全球最大的数字图书馆，截止2022年4月23日，官网显示共收录了<span style="background:#FF9999;">10132918</span>本书，<span style="background:#FF9999;">84837646</span>篇文章。嗯，我觉得他的自称没有问题。</p><p>Z-library收录的大部分书信息都很详细，其检索系统也很完善，书名、作者、ISBN、出版社等信息都可以作为检索条件。Z-library虽然是国外的网站，但其语言支持十分强大，不开翻译完全可以浏览整个网站，中文书籍资源也十分丰厚。</p><h2 id="Z-library的网站页面">Z-library的网站页面</h2><p><a href="https://zh.z-lib.org/">Z-library的主页</a>其实是一个门户，用于跳转到相应的网页</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/23/190839.png" alt="根据所在地区自动选择可用域名跳转"></p><center style="color:#404040">根据所在地区自动选择可用域名跳转</center><p>以书籍页面为例，打开后就是一个简约的搜索页面。上方是搜索框，下方是热门推荐的书籍展示，右上方的菜单可以进行登录，捐赠，快捷搜索和更多选项的操作。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/23/191320.png" alt="书籍页面"></p><center style="color:#404040">书籍页面</center><h2 id="Z-library的主要功能">Z-library的主要功能</h2><h3 id="书籍管理">书籍管理</h3><p>除了主页中展示的检索书籍功能之外，在更多选项中你可以向Z-library提供书籍（如果你是供应商的话），可以请求找不到的书籍，也可以查看别人的共享书单。如果登录了账号，还可以建立自己的个人书单或者分享自己的书单。</p><p>Z-library也提供了书籍的分类管理和挑选出最新上传或者最受欢迎的书籍，如果你对书籍的记忆只剩下了只言片语，Z-library也提供了全文搜索帮你找到想要的书籍。</p><h3 id="书籍信息">书籍信息</h3><p>在找到需要的书籍后的详情页面，Z-library也提供了内容简介，出版社等书籍信息和评论收藏等功能，体验与国内的豆瓣等信息提供网站别无二致。登录后可以将书籍加入书单或标记，也可以发表评论或对书籍评分。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/23/193825.jpeg" alt="以《杀死一只知更鸟》为例"></p><center style="color:#404040">以《杀死一只知更鸟》为例</center><h3 id="书籍阅读">书籍阅读</h3><p>书籍的详情页面可以选择在线预览（部分书籍，且只能预览前十页），也可以下载到本地阅读，默认提供的下载格式有pdf，epub，mobi等，因书而异。如果没有需要的格式，Z-library也提供了格式转换的功能（效果未知，没用过），不过需要登录。登录后，也可以通过Z-library将书籍发送到kindle或邮箱。</p><h2 id="Z-library的其他功能">Z-library的其他功能</h2><h3 id="下载限制">下载限制</h3><p>Z-library无需注册便可以下载，未注册每日的下载次数是五次，免费账户每天的下载次数是十次。另外每个ip每天也有限制（这意味着如果使用公共ip很有可能会因达到上限被限制下载）。这些限制其实对于普通个人用户来讲足以满足日常需求，但如果仍然想要提高下载上限，可以通过奖励机制（活跃用户之类的），或者捐赠来提高下载上限。</p><h3 id="tg机器人">tg机器人</h3><p>如果你是一名电报用户，你可以通过Z-library的tg机器人获得十次下载，这个不计入下载限制。</p><h3 id="博客和FAQ">博客和FAQ</h3><p>Z-library提供了一个博客网站发布官方的通知和更新等消息，同时还有一个FAQ页面回答了一些使用时可能会遇到的问题。</p><h2 id="Z-library的注意事项">Z-library的注意事项</h2><p>Z-library作为一个全球的公共库，其中的书籍内容和评论都是不会经过审查的。开放的环境也意味着鱼龙混杂的信息，未知真伪的言论以及持不同观点的思想，不论是在书籍中还是评论中。</p><blockquote><p><strong style="color:#ed3b2f;">请自行甄辩和处理各种信息，本人不负任何责任</strong></p></blockquote><p>Z-library主页被GFW封禁，可以通过国内镜像网站或科学上网访问，由于会被攻击或限制，镜像网站会频繁更换。</p><blockquote><p><strong style="color:#ed3b2f;">国内镜像网站和科学上网方法请自行寻找</strong></p></blockquote><h2 id="关于版权问题">关于版权问题</h2><p>Z-library对于知识产权有<a href="https://zh.1lib.tw/dmca.php">政策声明</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/23/203403.png" alt="政策声明"></p><center style="color:#404040">政策声明</center>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 世界图书日 </tag>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/posts/47718/"/>
      <url>/posts/47718/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="智能指针的原理和作用">智能指针的原理和作用</h2><h3 id="智能指针的作用">智能指针的作用</h3><p>在C++中，指针的使用离不开内存管理的知识(参见“指针和引用”)，内存管理又离不开堆和栈。其中栈由编译器自动管理，而堆需要程序员手动管理。在普通指针的使用过程中，经常需要申请释放堆内存，稍有不慎就会导致内存泄漏或者程序崩溃。智能指针就是为了更好地管理堆内存，解决手动管理堆内存容易产生的内存泄漏等问题。</p><h3 id="智能指针的原理">智能指针的原理</h3><ol><li>从较浅的层面看，智能指针是利用了一种叫做RAII（见下文）的思想对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把值语义转换成对象语义。</li></ol><blockquote><p>关于值语义和对象语义，你可以简单的理解为值语义相当于一个东西的属性和另一个东西的属性完全一样，但其实这是两个东西。而对象语义相当于一个东西的属性和另一个东西的属性完全一样，这其实是一个东西。C++的语法其实是值语义的，但面向对象却需要对象语义来解释，这就是C++中面向对象容易产生BUG的根源。更详细的解释，请移步<a href="http://www.cnblogs.com/Solstice/archive/2011/08/16/2141515.html">这篇大佬的文章</a>。</p></blockquote><h3 id="RAII编程思想">RAII编程思想</h3><p>关于RAII编程思想参考了这篇文章:<a href="https://blog.csdn.net/noahzuo/article/details/51139940">C++ —— RAII编程思想</a></p><h4 id="Class的构建和析构">Class的构建和析构</h4><p>C++相比C多了面向对象，面向对象的核心是一个一个Class，而Class的核心是构造函数和析构函数。</p><p>在C++中，如果Class的对象声明在栈，则当其生命周期结束后Class会自动调用析构函数将对象删除，但如果Class的对象声明在堆中(使用new或malloc方法)，则需要显示地调用析构函数才能进行析构。</p><h4 id="RAII">RAII</h4><p>RAII，即&quot;Resource Aquisition Is Initialization&quot;(资源获取即初始化)。RAII的思想很简单，就是<span style="background:#FF9999;">利用C++对象的生命周期来控制资源的获取释放</span>。简单来说，就是当程序员希望对某个资源进行管理，那么创建一个对象，并将资源的生命周期和对象的生命周期相关联，这时C++自带的对象管理就可以管理该资源。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>&#123;...&#125;; <span class="comment">// 需要控制的资源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceHandle</span>&#123; <span class="comment">// 管理类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="comment">// 获取资源</span></span><br><span class="line">         <span class="function"><span class="keyword">explicit</span> <span class="title">ResourceHandle</span><span class="params">(ResourceHandle *aResource )</span>: r_(aResource)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 释放资源</span></span><br><span class="line">         ~<span class="built_in">ResourceHandle</span>()</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">delete</span> r_;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取资源获取权限</span></span><br><span class="line">         <span class="function">Resource *<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">         </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> r_;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 确保资源不会被拷贝</span></span><br><span class="line">        <span class="built_in">ResourceHandle</span> (<span class="type">const</span> ResourceHandle &amp;);</span><br><span class="line">        ResourceHandle &amp; <span class="keyword">operator</span> = (<span class="type">const</span> ResourceHandle &amp;);</span><br><span class="line">        Resource *r_;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>ResoueceHandle类就是一个管理资源的类，一个ResourceHandle的对象如果被声明为一个函数的局部变量，或者作为一个参数或静态变量，都可以保证析构函数被调用，即该对象引用的资源被释放。</p><p>再来看一个反例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource *rh = <span class="keyword">new</span> Resource;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">blahblah</span>())</span><br><span class="line">         <span class="keyword">return</span> ;    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">g</span>();         <span class="comment">//触发异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能确保它可以在这里被处理吗？</span></span><br><span class="line">    <span class="keyword">delete</span> rh ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用普通的指针去指向一个堆内存，虽然加上了使用过后释放该内存的语句，但如上例所描述的那样，如果在<code>g()</code>函数调用过程中触发了异常导致程序崩溃，还能确保<code>delete rh</code>能够被执行，其所指的内存被释放吗？</p><p>如果利用上述的RAII思想对其进行改进，则结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ResourceHandle <span class="title">rh</span> <span class="params">(<span class="keyword">new</span> Resource)</span></span>; <span class="comment">//创建ResoueceHandle类的对象获取资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">blahblah</span>())</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里即使仍然触发异常</span></span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终仍会被析构函数释放</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如此，RAII使得代码更加健壮。但RAII仍有一种情况无法保证析构函数被调用，这就是当ResourceHandle对象被动态分配到堆内存上，这时仍然需要显式调用析构函数才能保证资源被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResourceHandle *rhp = <span class="keyword">new</span> <span class="built_in">ResourceHandle</span>(<span class="keyword">new</span> Resource);</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实质还是使用了普通的指针，只不过指向的不是原有的资源，而是资源管理对象。</span></span><br></pre></td></tr></table></figure><h2 id="智能指针的使用">智能指针的使用</h2><p>以C++11为准，智能指针有三类，分别为<code>shared_ptr</code>，<code>unique_ptr</code>，<code>weak_ptr</code>，其头文件为<memory>。</p><h3 id="unique-ptr"><code>unique_ptr</code></h3><p><code>unique_ptr</code>&quot;唯一&quot;占有其所指的对象。<code>unique_ptr</code>只有move方法而没有赋值和拷贝的方法，这意味着同一时刻只能有一个对象被<code>unique_ptr</code>所指。</p><p><code>unique_ptr</code>的生命周期为从创建<code>unique_ptr</code>指针开始，直到离开作用域。在<code>unique_ptr</code>的生命周期内，可以改变<code>unique_ptr</code>所指的对象（创建<code>unique_ptr</code>通过构造函数指定，通过<code>reset</code>方法重新指定，通过<code>release</code>方法释放所有权，通过<code>move</code>方法转移所有权）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">//从构造函数绑定对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; ptr1 = ptr; 报错，不能赋值</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;int&gt; ptr2(ptr); 报错，不能拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line">    <span class="comment">// ptr3.reset(ptr.get()); 编译报错，下面还有一条一样的语句</span></span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr4 = <span class="built_in">move</span>(ptr); <span class="comment">//转移所有权</span></span><br><span class="line">    ptr3.<span class="built_in">reset</span>(ptr.<span class="built_in">get</span>()); <span class="comment">//这次不报错</span></span><br><span class="line">    <span class="comment">// 因为在上面ptr所指的资源已经绑定了Ptr，所以通过reset重新指定Ptr3绑定的资源会与ptr重复</span></span><br><span class="line">    <span class="comment">// 而通过move方法将ptr所有权转移给Ptr4之后，ptr此时被释放了，其原始指针为nullptr</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ptr3.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)&#123;cout&lt;&lt;<span class="string">&quot;null&quot;</span>&lt;&lt;endl;&#125; </span><br><span class="line">    <span class="comment">//验证ptr3 reset之后原始指针也为nullptr</span></span><br><span class="line"></span><br><span class="line">    ptr4.<span class="built_in">release</span>(); <span class="comment">//释放所有权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr"><code>shared_ptr</code></h3><p><code>shared_ptr</code>可以使多个指针指向同一个对象，每一个拷贝都指向相同的内存。shared_ptr使用引用计数，每使用一次内部引用计数+1，析构一次引用计数-1，减到0后自动删除指向的堆内存。<code>shared_ptr</code>内部的引用计数是线程安全的，但读取时要加锁。</p><p><code>shared_ptr</code>并不是完美的，容易出现<a href="#circularReference">循环引用</a>的问题，这一问题会在介绍完<code>weak_ptr</code>之后介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量</span></span><br><span class="line">    <span class="type">int</span>* pa = &amp;a; <span class="comment">//定义指针</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(a);</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(*pa);</span><br><span class="line">    <span class="comment">// 通过make_shared方法定义创建shared_ptr对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// shared_ptr&lt;int&gt; ptr3 = &amp;a;</span></span><br><span class="line">    <span class="comment">// shared_ptr&lt;int&gt; ptr4 = pa;</span></span><br><span class="line">    <span class="comment">// 错误，shared_ptr本质是类，而&amp;a和pa是指针</span></span><br><span class="line"></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(a))</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr7</span><span class="params">(ptr6)</span></span>;</span><br><span class="line">    <span class="comment">// 通过构造函数创建shared_ptr对象</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ptr1.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ptr2.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ptr5.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ptr6.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ptr7.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出ptr1 2 5 6 7 的引用计数，为1 1 1 2 2，</span></span><br><span class="line">    <span class="comment">// 可以发现，虽然他们都指向的是一块值为10的内存空间，</span></span><br><span class="line">    <span class="comment">// 但其实通过值来创建shared_ptr对象是重新在堆中申请了一块内存空间的，并不指向原来的内存。</span></span><br><span class="line">    <span class="comment">// 而6 7的引用计数均为2，说明通过拷贝构造的share_ptr指向的是同一块内存空间。</span></span><br><span class="line">    <span class="comment">// 同时也可以得到拷贝会使引用计数+1。</span></span><br><span class="line"></span><br><span class="line">    ptr7 = ptr5;</span><br><span class="line">    cout&lt;&lt;ptr5.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ptr6.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ptr7.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 把ptr5赋值给ptr7,</span></span><br><span class="line">    <span class="comment">// 再次输出ptr5 6 7 的引用计数，为2 1 2，</span></span><br><span class="line">    <span class="comment">// 则可以发现，赋值会使原引用计数-1(ptr6)，后引用计数+1(ptr5)。</span></span><br><span class="line">    </span><br><span class="line">    pa = ptr7.<span class="built_in">get</span>() <span class="comment">//通过get()获取原始指针。</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 1. shared_ptr&lt;int&gt; ptr8(a);</span></span><br><span class="line">    <span class="comment">// 2. int* pb = new int(a);</span></span><br><span class="line">    <span class="comment">// 3. shared_ptr&lt;int&gt; ptr9(pb);</span></span><br><span class="line">    <span class="comment">// 4. shared_ptr&lt;int&gt; ptr10(pb);</span></span><br><span class="line">    <span class="comment">// 以上4条语句需要注意</span></span><br><span class="line">    <span class="comment">// 不要使用第一条语句的形式创建shared_ptr，shared_ptr对象应当由堆内存中创建。</span></span><br><span class="line">    <span class="comment">// 不要出现3 4语句的形式，即不要出现一个原始指针创建多个shared_ptr对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weak-ptr"><code>weak_ptr</code></h3><p><code>weak_ptr</code>是为了配合<code>shared_ptr</code>而引入的一种智能指针，因为<span style="background:#FF9999;">它不具有普通指针的行为，没有重载operator*和-&gt;</span>。<code>weak_ptr</code>最大的作用在于<span style="background:#FF9999;">协助shared_ptr工作，像旁观者那样观测资源的使用情况</span>。</p><p><code>weak_ptr</code>可以从一个<code>shared_ptr</code>或者另一个<code>weak_ptr</code>对象构造，获得资源的观测权。但<code>weak_ptr</code>没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>使用<code>weak_ptr</code>的成员函数<code>use_count()</code>可以观测资源的引用计数，另一个成员函数<code>expired()</code>的功能等价于<code>use_count()==0</code>,但更快，表示被观测的资源(也就是<code>shared_ptr</code>的管理的资源)已经不复存在。</p><p><code>weak_ptr</code>可以使用一个非常重要的成员函数<code>lock()</code>从被观测的shared_ptr获得一个可用的<code>shared_ptr</code>对象， 从而操作资源。但当<code>expired()==true</code>的时候，<code>lock()</code>函数将返回一个存储空指针的<code>shared_ptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_shared方法创建shared_ptr</span></span><br><span class="line">    cout&lt;&lt;ptr1.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>; <span class="comment">// 通过构造函数从shared_ptr创建一个weak_ptr</span></span><br><span class="line">    cout&lt;&lt;ptr1.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">// 输出 1 weak_ptr不影响shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用weak_ptr的expired方法，检查观测目标是否指向nullptr</span></span><br><span class="line">    <span class="keyword">if</span>(!ptr2.<span class="built_in">expired</span>())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lock方法可以获得一个可用的被观测的share_ptr的对象</span></span><br><span class="line">        <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr3</span><span class="params">(ptr2.lock())</span></span>;</span><br><span class="line">        *ptr3.<span class="built_in">get</span>() = <span class="number">100</span>;</span><br><span class="line">        cout&lt;&lt;ptr1.<span class="built_in">use_count</span>()&lt;&lt;endl; <span class="comment">//输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="circularReference"></a></p><h3 id="循环引用">循环引用</h3><h4 id="问题产生">问题产生</h4><p>循环引用指的是当两个对象互相强引用对方(通过<code>shared_ptr</code>)，从而因为无法完成释放对象导致内存泄漏。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/22/205510.png" alt=""></p><p>这是由于<code>shared_ptr</code>使用引用计数，当引用计数为0时才调用析构函数从而释放内存。故脱离作用域后A需要等待B释放来使A的引用计数减为0，B同样需要等待A释放来使B的引用计数减为0，最终A B都无法释放导致内存泄漏。</p><p>来看一个简单的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m A!&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A: I&#x27;m free!&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Make</span><span class="params">(shared_ptr&lt;B&gt; pb)</span> </span>&#123; </span><br><span class="line">        pb_ = pb; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_; <span class="comment">//指向一个B类的shared_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m B!&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B: I&#x27;m free!&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Make</span><span class="params">(shared_ptr&lt;A&gt; pa)</span> </span>&#123; </span><br><span class="line">        pa_ = pa; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_; <span class="comment">// 指向一个A类的shared_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pta</span><span class="params">(<span class="keyword">new</span> A())</span></span>; <span class="comment">// 此时pta引用计数为1</span></span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">ptb</span><span class="params">(<span class="keyword">new</span> B())</span></span>; <span class="comment">// 此时ptb引用计数为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        pta-&gt;<span class="built_in">Make</span>(ptb); <span class="comment">// 此时ptb引用计数为2</span></span><br><span class="line">        ptb-&gt;<span class="built_in">Make</span>(pta); <span class="comment">// 此时pta引用计数为2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//脱离作用域，pta和ptb引用计数都减为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// I&#x27;m A!</span></span><br><span class="line"><span class="comment">// I&#x27;m B!</span></span><br></pre></td></tr></table></figure><p>可以看到脱离作用域后由于pta和ptb的引用计数都未减为0，A和B的析构函数均未被调用，出现内存泄漏。</p><h4 id="解决方案">解决方案</h4><p>循环引用的解决方案就是利用<code>weak_ptr</code>的弱引用性质实现的，将A B互相的强引用中其中一方变为弱引用，因为弱引用是不增加引用计数的，所以最终会使引用计数都减为0，从而调用析构函数释放内存。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针和引用</title>
      <link href="/posts/22647/"/>
      <url>/posts/22647/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C++中非常重要的一个工具就是强大灵活的指针，当然他的灵活也会导致一些琐碎的问题和细节上需要注意的事项，这篇就来整理一下指针的相关知识。</p><h2 id="什么是指针">什么是指针</h2><p>在C++中，定义了变量一般会在内存中随机分配一块地址，而指针则可以间接地访问到内存中的地址进行数据的读写。</p><p>由于指针与内存的联系十分紧密，要想理解指针，首先要从内存说起。</p><h2 id="变量在内存中的存储">变量在内存中的存储</h2><p>程序中定义了一个<code>int a = 1</code>，那么其在内存中的存储格式是这样的：</p><table><thead><tr><th style="text-align:center">…</th><th style="text-align:center">…</th><th style="text-align:center">…</th><th style="text-align:center">00000000</th><th style="text-align:center">00000000</th><th style="text-align:center">00000000</th><th style="text-align:center">00000001</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">低地址</td><td style="text-align:center">0028FF40</td><td style="text-align:center">0028FF41</td><td style="text-align:center">0028FF42</td><td style="text-align:center">0028FF43</td><td style="text-align:center">高地址</td></tr></tbody></table><p>int类型占4个字节，其首地址表示占据内存的地址</p><p>用来保存指针的对象也是一种变量，如果定义一个指针int* p保存a的地址(即p指向a)，则其在内存中的存储是这样的：</p><table><thead><tr><th style="text-align:center">…</th><th style="text-align:center">0028FF40</th><th style="text-align:center">…</th><th style="text-align:center">00000000</th><th style="text-align:center">00000000</th><th style="text-align:center">00000000</th><th style="text-align:center">00000001</th><th style="text-align:center">…</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">xxxxxxxx</td><td style="text-align:center"></td><td style="text-align:center">0028FF40</td><td style="text-align:center">0028FF41</td><td style="text-align:center">0028FF42</td><td style="text-align:center">0028FF43</td><td style="text-align:center">高地址</td></tr></tbody></table><h2 id="指针的基本使用">指针的基本使用</h2><h3 id="指针变量的定义">指针变量的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p_int;   <span class="comment">//指向int类型变量的指针         </span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span>* p_double;  <span class="comment">//指向double类型变量的指针  </span></span><br><span class="line">   </span><br><span class="line">Student* p_struct;  <span class="comment">//类或结构体类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>** p_pointer;  <span class="comment">//指向 一个整形变量指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>(*p_arr)[<span class="number">3</span>];  <span class="comment">//指向含有3个int元素的数组的指针 </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span>(*p_func)(<span class="type">int</span>,<span class="type">int</span>);  <span class="comment">//指向返回类型为int，有2个int形参的函数的指针  </span></span><br></pre></td></tr></table></figure><h3 id="指针变量的解析">指针变量的解析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">*p = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="指针的算数运算">指针的算数运算</h3><p>指针可以通过加上或减去一个整数访问其他内存地址，其运算是根据指针的数据类型来执行的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p1 = arr;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>* p2 = str;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;*p1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*(p1+<span class="number">1</span>)&lt;&lt;endl; <span class="comment">//1 2</span></span><br><span class="line">cout&lt;&lt;*p2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*(p2+<span class="number">1</span>)&lt;&lt;endl; <span class="comment">//1 2</span></span><br></pre></td></tr></table></figure><p>上面例子可以看出虽然p1，p2都是加了1，但他们并不是都指向了原地址后一个字节的地址，而是根据不同的数据类型，乘以了<code>sizeof(type)</code>。</p><h2 id="空指针和野指针">空指针和野指针</h2><h3 id="空指针">空指针</h3><h4 id="空指针常量">空指针常量</h4><p>一个表示0值的整数常量，叫做空指针常量。例如：0、0L、1-1（它们都是值为0的整数常量表达式）以及<code>(void*)0、void* NULL</code> 都是空指针常量，空指针常量可以赋值给任何指针类型，因为它是变体类型<code>（void*）</code>。但是我们更倾向于使用NULL表示这个空指针常量。对于其它方式（比如0）来表示空指针常量虽然不会产生任何问题，但是在根本意义上并不符合空指针常量的定义。因为空指针常量的存在意义还在强调它并不指向任何对象</p><h4 id="空指针-2">空指针</h4><p>空指针不指向任何实际的对象或者函数。</p><p>空指针是一个特殊的指针，因为这个指针不指向任何地方。这意味任何一个有效的指针如果和空指针进行相等的比较运算时，结果都是false。</p><h4 id="空指针指向内存的什么地方">空指针指向内存的什么地方</h4><p>标准并没有对空指针指向内存中的什么地方这一问题作出规定，也就是说用哪个具体地址值表示空指针取决于系统实现。我们常见的空指针一般指向0地址，即空指针的内部用全0来表示。<span style="background:#FF9999;">这个地址没有实际的物理地址与之对应，所以访问这个地址会报空指针异常</span>。</p><h3 id="野指针">野指针</h3><p>野指针不是空指针，是一个指向非法内存空间的指针。</p><h4 id="野指针的产生原因">野指针的产生原因</h4><ol><li>指针变量没有初始化</li></ol><p>任何指针变量被刚创建时不会被自动初始化为NULL指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p><ol start="2"><li>指针被delete或free后没有及时置空或指向其他有效地址</li></ol><p>free和delete只是把指针所指向的内存给释放掉，但并没有把指针本身给清理掉。这时候的指针依然指向原来的位置，只不过这个位置的内存数据已经被毁尸灭迹，此时的这个指针指向的内存就是一个垃圾内存。</p><ol><li>指针超越变量作用范围</li></ol><p>因为指针可以做算数运算，故可能会由于运算导致指针指向了变量以外的内存空间。另一种情况是函数返回了<span style="background:#FF9999;">非静态局部变量的地址</span>，因为该变量已经脱离了作用域而被系统销毁，此时接受返回值的指针就是一个野指针，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    <span class="type">int</span>* p = &amp;sum;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//不要返回临时变量的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">test</span>(a, b);</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数和指针">函数和指针</h2><p><a id="functionParametersAndPointers"></a></p><h3 id="函数的参数和指针">函数的参数和指针</h3><p>实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。</p><p>当然可以通过返回值将修改后的参数返回，但当需要修改的参数不止一个，返回值就无能为力了，传递参数的指针就可以解决这个问题，指针传递的是参数的地址，当形参改变，实参也会跟着改变。</p><h3 id="函数的返回值和指针">函数的返回值和指针</h3><p>当函数的返回值是一个指针，那么可以称为指针函数，其本质是一个函数。</p><p>唯一需要注意的一点是上文提到的不要<span style="background:#FF9999;">返回非静态局部变量的地址</span>，会产生野指针。</p><h3 id="函数的指针">函数的指针</h3><p>即函数指针，其本质是一个指向函数的指针，不要和指针函数混淆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>); <span class="comment">//函数指针的声明，该指针指向有两个整形参数，返回整型的一个函数</span></span><br><span class="line">    p = test; <span class="comment">//函数名就是函数的地址</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">p</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//函数指针可以直接当函数名进行调用</span></span><br><span class="line">    cout&lt;&lt;(*p)(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//也可以解指针后调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const和指针">const和指针</h2><p>const作为修饰词，其在搭配指针使用时非常重要的一个知识就是const修饰的对象是谁。</p><blockquote><p>注意使用了const修饰词，必须初始化哦</p></blockquote><h3 id="常量指针">常量指针</h3><p>常量指针指的是指向一个常量的指针，即指针的值可以更改，但指针的指向的内容无法通过指针更改(指针指向的是常量)。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = a; <span class="comment">//定义常量指针 也可写为 int const* p = a;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*p = 5; 报错，无法通过指针更改指向的内容</span></span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;*p&lt;&lt;endl; <span class="comment">//输出 2</span></span><br></pre></td></tr></table></figure><p><a id="pointerConstant"></a></p><h3 id="指针常量">指针常量</h3><blockquote><p>也叫常指针</p></blockquote><p>指针常量指的是指针作为一个常量，即指针的值无法更改，但指针指向的内容可以通过指针更改。示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = a;</span><br><span class="line"></span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line">cout&lt;&lt;a[<span class="number">1</span>]&lt;&lt;endl; <span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p++; 报错，指针的值无法更改</span></span><br></pre></td></tr></table></figure><h3 id="const同时修饰指针和常量">const同时修饰指针和常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p = a;</span><br><span class="line"><span class="comment">//*p = 5;</span></span><br><span class="line"><span class="comment">//p++;</span></span><br><span class="line"><span class="comment">//均报错，既不能更改指针的值，也不能通过指针更改指向的内容。</span></span><br></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝">浅拷贝和深拷贝</h2><p>对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。</p><p>对于简单的类，默认的拷贝构造函数一般就够用了，他会以浅拷贝的方式去构造，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。</p><p>但类有<span style="background:#FF9999;">动态分配的内存</span>、<span style="background:#FF9999;">指向其他数据的指针</span>等资源时，浅拷贝就无法胜任了，这时需要显式的定义拷贝构造函数，以完整的拷贝对象的所有数据。</p><p>举一个简单的例子：</p><p>假设我们自定义一个变长数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span> n); <span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A &amp;a); <span class="comment">//拷贝构造函数</span></span><br><span class="line">        ~<span class="built_in">A</span>(); <span class="comment">//析构函数</span></span><br><span class="line">        <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)&#123;<span class="keyword">return</span> *(A_p+i);&#125; <span class="comment">//重写[]操作符使其支持读写</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> A_len;&#125; <span class="comment">//获得数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> A_len; <span class="comment">//数组长度</span></span><br><span class="line">        <span class="type">int</span>* A_p; <span class="comment">//数组指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;A_len = n;</span><br><span class="line">    <span class="keyword">this</span>-&gt;A_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(A_len, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> A &amp;a)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;A_len = a.A_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;A_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="keyword">this</span>-&gt;A_len, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;A_p, a.A_p, <span class="keyword">this</span>-&gt;A_len*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::~<span class="built_in">A</span>()&#123;</span><br><span class="line">    <span class="built_in">free</span>(A_p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来写一个打印函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">(<span class="type">const</span> A&amp; arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main</code>函数中测试一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//调用构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr1.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        arr1[i] = i; <span class="comment">//循环赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">A <span class="title">arr2</span><span class="params">(arr1)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    arr2[<span class="number">2</span>] = <span class="number">100</span>; <span class="comment">//改一个值</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;arr1: &quot;</span>;</span><br><span class="line">    <span class="built_in">printA</span>(arr1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;arr2: &quot;</span>;</span><br><span class="line">    <span class="built_in">printA</span>(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">arr2: 0 1 100 3 4 5 6 7 8 9 </span><br></pre></td></tr></table></figure><p>可以看出，我们显式的重构了拷贝构造函数，它<span style="background:#FF9999;">除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来</span>。这样做的结果是，<span style="background:#FF9999;">原有对象和新对象所持有的动态内存是相互独立的</span>，更改一个对象的数据不会影响另外一个对象。</p><p>接下来我们将重构的拷贝构造函数注释掉，使A类使用默认的拷贝构造函数，不改变<code>main</code>函数，重新编译一下，结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1: 0 1 100 3 4 5 6 7 8 9 </span><br><span class="line">arr2: 0 1 100 3 4 5 6 7 8 9 </span><br></pre></td></tr></table></figure><p>可以看到更改arr2的同时arr1也发生了改变。不仅如此，在编译时会在析构函数中中断，这是由于浅拷贝导致的arr1和arr2的数组指针指向的是同一个内存空间，在arr1和arr2生命周期结束后系统分别调用了其析构函数，出现了指针悬挂的问题。也可以理解为上文<a href="#functionParametersAndPointers">野指针产生原因</a>的第2点，即arr1的指针指向的数组所在的内存空间被释放，但此时仍有另一个指针指向该空间，成了野指针。</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/20/144706.png" alt=""></p><p>当然我们也可以换更直观的方式，在注释掉重构的拷贝构造函数后，修改一下<code>main</code>函数，在打印完<code>arr1</code>后手动调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">arr1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//调用构造函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr1.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        arr1[i] = i; <span class="comment">//循环赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">A <span class="title">arr2</span><span class="params">(arr1)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    arr2[<span class="number">2</span>] = <span class="number">100</span>; <span class="comment">//改一个值</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;arr1: &quot;</span>;</span><br><span class="line">    <span class="built_in">printA</span>(arr1);</span><br><span class="line">    arr1.~<span class="built_in">A</span>(); <span class="comment">//手动调用析构函数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;arr2: &quot;</span>;</span><br><span class="line">    <span class="built_in">printA</span>(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">arr2: 14556832 0 14549328 0 -17891602 -17891602 -17891602 -17891602 -17891602 -17891602</span><br></pre></td></tr></table></figure><h2 id="引用">引用</h2><p>虽然标题叫指针和引用，怎么没有一点引用的知识呢？这不就来了吗。</p><h3 id="引用的概述">引用的概述</h3><p>引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&amp;代替了*。引用（reference）是c++对c语言的重要扩充。引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。其格式为：类型 &amp;引用变量名 = 已定义过的变量名。</p><p>引用的特点：</p><ol><li><p>一个变量可取多个别名。</p></li><li><p>引用必须初始化。</p></li><li><p>引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量。</p></li></ol><h3 id="引用的应用">引用的应用</h3><h4 id="引用做函数参数">引用做函数参数</h4><p>这个部分和上文的<a href="#functionParametersAndPointers">指针做函数参数</a>类似，同样可以通过形参改变实参。</p><h4 id="引用做函数返回值">引用做函数返回值</h4><p>当函数返回值作为<span style="background:#FF9999;">左值</span> 那么函数的返回值类型必须是<span style="background:#FF9999;">引用</span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;num = &quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// num = 10</span></span><br><span class="line"><span class="comment">// num = 20</span></span><br></pre></td></tr></table></figure><h3 id="引用的本质">引用的本质</h3><p>c++编译器在编译过程中使用<a href="#pointerConstant">指针常量</a>作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。</p><p>引用可以理解为指针常量的封装。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;a = data;<span class="comment">//a就是data的别名</span></span><br><span class="line"><span class="comment">//编译器内存转换：int * const a = &amp;data;</span></span><br></pre></td></tr></table></figure><p>这也是为什么引用的特点：</p><ul><li>必须初始化（因为指针常量必须初始化）</li><li>只能在初始化时引用一次，不能改为应用其他变量（因为指针常量的值不能更改）</li><li>可以通过引用修改元素的值（因为指针常量可以更改指向的值）</li></ul><h3 id="常引用">常引用</h3><blockquote><p>我一直觉得C++中有些命名就是为了恶心你</p></blockquote><p>常引用就是加入<code>const</code>修饰的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;a = data;</span><br><span class="line"><span class="comment">// 编译器内存转换：int * const a = &amp;data;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = data;</span><br><span class="line"><span class="comment">// 编译器内存转换：const int* const b = &amp;data;</span></span><br></pre></td></tr></table></figure><p>结合引用的本质，实际上就是<code>const</code>既修饰常量又修饰指针，其值不可更改，指向的值也不可更改，多用于只读的函数中传递参数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const，define，typedef的区别和联系</title>
      <link href="/posts/30793/"/>
      <url>/posts/30793/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先，这三个不是放在一起来对比的，而是分为两个部分：<code>define</code>与<code>const</code>的区别与联系和<code>define</code>和<code>typedef</code>的区别与联系。因为这两个要讨论的内容就不是同一个方向的。</p><h2 id="define和const的区别和联系"><code>define</code>和<code>const</code>的区别和联系</h2><p><code>define</code>和<code>const</code>都可以来定义常量，但是这两种方式定义的常量是有区别的。</p><ul><li>define是通过宏定义的方式来定义常量的，对其定义的常量不做类型安全检查，只是单纯的展开，在预编译阶段进行。其定义的常量在内存中可能会有多份拷贝，占用内存空间大。</li><li>const定义的常量是有数据类型的，该替换在编译阶段进行，编译时会对const定义的常量进行类型检查。其定义的常量存放在静态存储区，只有一份拷贝。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/19/101221.png" alt="内存分区"></p><h2 id="define和typedef的区别和联系"><code>define</code>和<code>typedef</code>的区别和联系</h2><ul><li><span style="background:#FF9999;">用法不同</span>，<code>define</code>用来定义常量；<code>typedef</code>用来定义数据类型的别名</li><li><span style="background:#FF9999;">执行时间不同</span>，<code>define</code>是宏定义，在预编译阶段执行，不做类型检查；<code>typedef</code>在编译阶段执行，需要进行类型检查。</li><li><span style="background:#FF9999;">作用域不同</span>，<code>define</code>在预编译阶段就已经执行，故只要在<code>define</code>后声明的都会进行替换，没有作用域之说；<code>typedef</code>有自己的作用域，取决于定义时的位置。</li><li><span style="background:#FF9999;">含义不同</span>，<code>define</code>不是语句，而<code>typedef</code>定义是一条语句。</li></ul><p>除此之外，<code>typedef</code>还有其自己的多种使用方式，我认为seventhsaint的<a href="https://www.cnblogs.com/seventhsaint/archive/2012/11/18/2805660.html">C++ typedef用法详解</a>讲解的十分清楚，可参考学习。</p><p>当然这里会提到两个经常用来考的当<code>define</code>和<code>typedef</code>用来定义指针时的问题。</p><hr><p><span style="background:#FF9999;">情景1</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR1 int*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span>* INTPTR2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    INTPTR1 p1, p2; <span class="comment">//实际为int* p1, p2;</span></span><br><span class="line">    INTPTR2 p3, p4; <span class="comment">//实际为int* p1, int* p2;</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">typeid</span>(p1).<span class="built_in">name</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(p2).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">typeid</span>(p3).<span class="built_in">name</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(p4).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">typeid</span>(a).<span class="built_in">name</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">typeid</span>(b).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// pi i</span></span><br><span class="line">    <span class="comment">// pi pi</span></span><br><span class="line">    <span class="comment">// i i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上情景可以看出，<code>define</code>在做替换时只是单纯的字符串替换，则实际上定义p1为int*类型，p2为int类型。而<code>typedef</code>定义的是类型的别名，故实际上是定义了两个int*类型的变量。</p><hr><p><span style="background:#FF9999;">情景2</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR1 int*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span>* INTPTR2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> INTPTR1 p1 = &amp;a;</span><br><span class="line">    <span class="type">const</span> INTPTR2 p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">    p1 = &amp;b;</span><br><span class="line">    <span class="comment">//*p1 += 1; 编译错误，p1是常量指针，无法通过p1更改指向的值(卡住p1写的功能)</span></span><br><span class="line"></span><br><span class="line">    *p2 += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//p2 = &amp;a; 编译错误，p2是指针常量，无法更改p2指向的位置(卡住p2读的功能)</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// 3 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上情景在定义p1，p2时加入了const修饰，必须初始化。同样的，<code>define</code>只是单纯的字符串替换，<code>const INTPTR1 p1</code>实际上就是<code>const int* p1</code>，p1是一个常量指针；而<code>typedef</code>是类型的别名，<code>const INTPTR2 p2</code>实际上是<code>int* const p2</code>，p2是一个指针常量。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++显示类型转换</title>
      <link href="/posts/42322/"/>
      <url>/posts/42322/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="static-cast"><code>static_cast</code></h2><p><code>static_cast</code>支持窄化转换（信息丢失），<code>void*</code>强制转换，隐式类型转换和类层次转换（不安全）</p><h3 id="窄化转换">窄化转换</h3><p>窄化转换是说将占用字节较多的类型转化为占用字节较少的类型。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d1 = <span class="number">2.0</span>;</span><br><span class="line"><span class="type">int</span> i1;</span><br><span class="line"></span><br><span class="line">i1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d1);</span><br><span class="line">cout&lt;&lt;i1&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：2</span></span><br></pre></td></tr></table></figure><h3 id="void-前置转换">void* 前置转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">2</span>;</span><br><span class="line"><span class="type">void</span>* vv1 = &amp;i1;</span><br><span class="line"><span class="comment">//double* dd1 = vv1; 报错，C++不允许void*转换为其他类型指针</span></span><br><span class="line"><span class="type">int</span>* ii1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(vv1);</span><br><span class="line">cout&lt;&lt;*ii1&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：2</span></span><br></pre></td></tr></table></figure><h3 id="隐式转换">隐式转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1 = <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> d2, d3;</span><br><span class="line">d2 = i1;</span><br><span class="line">d3 = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i1);</span><br><span class="line">cout&lt;&lt;d2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d3&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输出：2 2</span></span><br></pre></td></tr></table></figure><h3 id="类层次转换">类层次转换</h3><p>类层次转换在dynamic_cast的范畴内，这里放到下面dynamic_cast中对比</p><h2 id="dynamic-cast"><code>dynamic_cast</code></h2><p><code>dynamic_cast</code>主要是一种类型安全的下行类型转换操作，它的<code>type_id</code>必须是类的指针、引用或者是<code>void*</code>，它与<code>static_cast</code>在类层次的转换有所区别。</p><h3 id="类型转换与RTTI">类型转换与<code>RTTI</code></h3><p>顾名思义的话，<code>static_cast</code><span style="background:#FF9999;">是静态的类型转换</span>操作，而<code>dynamic_cast</code>就是<span style="background:#FF9999;">动态的类型转换</span>，即根据实际对象动态地转换，这里所说的动态主要体现的是<span style="background:#FF9999;">所传入的对象类型必须含有虚函数</span>——因为它是靠存储在vtable上的类型信息来判断实际的类型，而<code>dynamic_cast</code>这种动态识别对象信息的能力又称<code>RTTI（run-time type information)</code></p><p><code>RTTI</code>机制的出现与C++本身是静态类型语言有关，即C++的数据类型是在编译时就确定的，不能在运行时更改，然而由于面向对象的多态性要求，C++中指针或引用本身的类型可能与它实际代表（指向或引用）的不同，有时便需要将一个多态指针转换为其实际指向对象的类型（为了访问特有的属性或方法），这时就需要知道运行时的类型信息，就产生了运行时类型识别的需求，<span style="background:#FF9999;">C++中获得运行时类型信息就是通过RTTI机制来完成的</span>。</p><h3 id="上下行转换">上下行转换</h3><p>类层次转换分为上行转换和下行转换，<span style="background:#FF9999;">上行转换总是安全的，一个父类（基类）指针或引用总是可以指向一个子类的对象的</span>，但下行转换就不一样了。子类（派生类）指针指向父类对象是不安全的，因为父类对象没有办法访问到子类的特有成员函数。这也就是体现出<code>stactic_cast</code>和<code>dynamic_cast</code>的不同之处，举一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设我们有一个动物类，动物类有一个狗狗子类。</span></span><br><span class="line"><span class="comment">//动物类有一个属性type，默认为“动物”。</span></span><br><span class="line"><span class="comment">//狗狗类有一个自己的属性dog_type，表示狗狗的具体种类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animals</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string type;</span><br><span class="line">    <span class="built_in">Animals</span>()&#123;</span><br><span class="line">        type = <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:<span class="keyword">public</span> Animals&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string dog_type;</span><br><span class="line">    <span class="built_in">Dog</span>(string dtype)&#123;</span><br><span class="line">        dog_type = dtype;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在我们需要一个方法，对传入的动物类对象进行检查，</span></span><br><span class="line"><span class="comment">//如果是狗狗我们需要输出具体的dog_type，</span></span><br><span class="line"><span class="comment">//如果不是狗狗我们只需要输出动物的type。</span></span><br><span class="line"><span class="comment">//在这个方法中分别使用dynamic_cast和static_cast进行类型转换后处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">me</span><span class="params">(Animals* animal)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;使用dynamic转换&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Dog* d_dynamic = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(animal);</span><br><span class="line">    <span class="keyword">if</span>(d_dynamic)&#123;</span><br><span class="line">        cout&lt;&lt;d_dynamic-&gt;dog_type&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;animal-&gt;type&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;使用static转换&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Dog* d_static = <span class="built_in">static_cast</span>&lt;Dog*&gt;(animal);</span><br><span class="line">    <span class="keyword">if</span>(d_static)&#123;</span><br><span class="line">        cout&lt;&lt;d_static-&gt;dog_type&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;animal-&gt;type&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//我们用两个动物类指针分别指向一个狗狗类对象和一个动物类对象    </span></span><br><span class="line">    Animals* dog0 = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">&quot;牧羊犬&quot;</span>);</span><br><span class="line">    Animals* notdog0 = <span class="keyword">new</span> <span class="built_in">Animals</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对两个指针应用上文的方法。</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;第一种情况&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">me</span>(dog0);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n第二种情况&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">me</span>(notdog0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//第一种情况</span></span><br><span class="line"><span class="comment">//使用dynamic转换</span></span><br><span class="line"><span class="comment">//牧羊犬</span></span><br><span class="line"><span class="comment">//使用static转换</span></span><br><span class="line"><span class="comment">//牧羊犬</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//第二种情况</span></span><br><span class="line"><span class="comment">//使用dynamic转换</span></span><br><span class="line"><span class="comment">//动物</span></span><br><span class="line"><span class="comment">//使用static转换</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//[Done] exited with code=3221225477 in 1.09 seconds</span></span><br></pre></td></tr></table></figure><p>可以看到，当父类指针指向的确实是一个子类对象时，<code>static_cast</code>和<code>dynamic_cast</code>都能正常转换，而<span style="background:#FF9999;">当父类指针指向的仍是一个父类对象时，<code>dynamic_cast</code>不能强制转换而是返回空指针</span>；<code>static_cast</code>则是强制转换，由于此时子类指针指向了父类对象，访问子类的特有属性时就会出现问题而且编译器不会报告语法错误。</p><h3 id="总结">总结</h3><ul><li><code>static_cast</code>是静态的类型转换，<code>dynamic_cast</code>是动态的类型转换</li><li>上行转换（子类转换为父类）是安全的，下行转换（父类转子类）是不安全的</li><li>C++中动态类型转换是通过<code>RTTI</code>机制来实现的</li><li><code>RTTI</code>机制是为了解决面向对象中多态指针在运行时指向的实际对象类型</li><li><code>dynamic_cast</code>传入的对象类型必须含有虚函数，因为实际对象类型是通过虚函数表得到的</li><li>当使用<code>dynamic_cast</code>进行下行转换时，会返回空指针</li></ul><h2 id="const-cast"><code>const_cast</code></h2><p><code>const_cast</code>是用来进行<code>const</code>相关的转换，可以把一个<code>const</code>对象转换为一个<code>非const</code>对象，同理，反其道而行也是可以的；另外 还可以用来进行<code>volatile</code>的转换。</p><blockquote><p><code>volatile</code>是一个特征修饰符(type specifier)。<code>volatile</code>的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。<code>volatile</code>的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。</p></blockquote><p>一般来说，<code>非const</code>对象转换为<code>const</code>对象是没问题的，所以其实没必要使用<code>const_cast</code>。主要是<code>const</code>对象转<code>非const</code>对象，这样就可以修改一个<code>const</code>对象的值了。</p><p>另外，<code>type_id</code>必须是指针或引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//int* b = &amp;a; 报错，不允许指针变量指向常量。</span></span><br><span class="line"><span class="type">int</span>* c = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);</span><br><span class="line">*c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;*c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//2 5</span></span><br><span class="line"><span class="comment">//0x61fe14 0x61fe14</span></span><br></pre></td></tr></table></figure><p>奇迹发生了但又没完全发生</p><p>可以看到<code>c</code>确实和<code>a</code>指向的同一块地址，但是他们的值却不同。根据反汇编的结果，好像是编译器直接提前将<code>a</code>的所有引用全部替换为了常量<code>5</code>，因为既然都指明了<code>a</code>是<code>const</code>的<code>5</code>，谁会想到你后面会尝试修改它呢。</p><h2 id="reinterpret-cast"><code>reinterpret_cast</code></h2><p><code>reinterpret_cast</code>运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数(<code>expressoin</code>)有完全相同的比特位。</p><p>reinterpret_cast的功能十分强大，可以互相转换任意类型的指针，也可将任意类型的指针转换为足够大的整型值。但随意的转换可能会造成程序的破坏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里随便定义了一个参数和返回值都是int的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建了一个函数指针fp指向test</span></span><br><span class="line">    <span class="built_in">int</span> (*fp)(<span class="type">int</span>) = test;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//强制将函数指针转换为double型指针，并且输出改地址的值</span></span><br><span class="line">    <span class="type">double</span>* val = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(fp);</span><br><span class="line">    cout&lt;&lt;*val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：5.65271e-134</span></span><br></pre></td></tr></table></figure><p>以上操作毫无意义，且代码也无法让人理解，但它并没有任何报错和警告。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《怪奇物语》第四季官方预告浅谈</title>
      <link href="/posts/58609/"/>
      <url>/posts/58609/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>People say Hawkins<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="霍金斯: 前三季故事的主要发生地。(另:本文其他剧集相关词汇均使用原名,注释会做解释)">[0]</span></a></sup> is cursed, They’re not way off.</p></blockquote><hr><p>刚刚看完了最新的《怪奇物语》第四季的最新<a href="https://www.youtube.com/watch?v=yQEondeGvKo">预告片</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="中文字幕版 <https://weibo.com/tv/show/1034:4757728514736336>">[1]</span></a></sup>，我只能说，剧神回来了！三年啊，你知道我这三年是怎么过来的吗？我把前三季每年重新看了一遍啊。</p><p>言归正传，这次的预告片相比前几次的前导预告，信息量多了不少。之前的彩蛋向，谜语人般的前导预告，只是给出了一个大致的背景，而且让我一度认为这部剧快要完结了，这一季是来补齐剩下的一些碎片(比如完善Eleven<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="十一: 女主，拥有使用意念操控物体的能力">[2]</span></a></sup>的过去，侦听到Russia<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="俄国: 毕竟设定是80年代的美国，反派懂得都懂">[3]</span></a></sup>的情报发现Hopper<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="霍珀: 霍金斯局长，第二季收养了十一，第三季剧中被认为牺牲，但片尾彩蛋暗示了其被俄国俘获">[4]</span></a></sup>原来还活着以及Russia也有关于Demogorgon<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="魔王: 源自于主角团玩的DND，是颠倒世界的怪物">[5]</span></a></sup>的研究，最终去营救身处俄国的Hopper同时最终摧毁Upside Down<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="颠倒世界: 存在于另一个位面，在霍金斯有入口">[6]</span></a></sup>)。但这次的预告片放出的画面又让我眼前一亮，当时追着第二季第三季的那种感觉又涌上心头，没有想到Duffer brother<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="杜夫兄弟: 《怪奇物语》的主创">[7]</span></a></sup>还能继续扩大《怪奇物语》的世界观和故事线。</p><h3 id="更大的世界与诅咒">更大的世界与诅咒</h3><p>这次的预告片很好地展示了前导预告中四个不同的地区Russia，The Lab<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="霍金斯实验室: 曾经十一被作为实验体囚禁在这里，同时也存在进入颠倒世界的入口">[8]</span></a></sup>，Creel House<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="克里尔之屋: 位于霍金斯，过去在这里有灵异事件发生">[9]</span></a></sup>，California。场景将更加多样，更加广阔。但当人们以为事件过去之后，真的可以放下过去，重新开始，或者在另一个地方正常生活吗？答案显然是否定的。旧事件的结束只是新事件的开始，无论是在Hawkins，还是在Hawkins外，这似乎是一种命运，但更像是一种诅咒。那些过去的，结束的经历仍然像无法摆脱的蛛丝，缠绕着一个个角色，拖动着他们最终仍要去面对诅咒的根源。<img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/13/144308.jpg" alt="第四季海报"></p><h3 id="黑暗的氛围与成长">黑暗的氛围与成长</h3><p>在前导预告中未被展示出来的黑暗面在本次预告中大量出现，给我一种看《哈利·波特》的感觉。在《哈利·波特与火焰杯》之前，故事的基调是魔法世界的奇妙与少年时期的勇敢冒险，所谓的邪恶与黑暗更像是一种挑战，而随着年龄的增长，他们接触到的世界开始变得复杂：死亡，离别，抉择开始不断摆在他们面前，故事的基调于是开始变得更加阴暗。Hawkins也是同样，从少年时的探索与冒险，到青少年的懵懂与叛逆，现在他们变得更加成熟，压力也随之而来。相比于前三季，角色们的生活面临着更大的变化与挑战，同时故事的氛围也变得更加阴暗。<img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/13/152755.jpg" alt="阴暗的Creel House"></p><h3 id="饱满的形象与过去">饱满的形象与过去</h3><p>提到饱满的人物形象，除了主角团外不得不说的就是Joseph<sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="约瑟夫·哈灵顿: 片中角色，本次预告中再次与留在霍金斯的角色一起进入克里尔之屋">[10]</span></a></sup>了。一开始作为刻板的“恶霸”形象出现在剧集中，但随着其内心善良性格的激发，他发现了自己的错误行为并开始补偿他过去犯过的错，同时他也与主角团的孩子们结下了真诚的友谊甚至成为了保护他们的“男妈妈”。而从第二季开始出场的Billy，在第二季中以暴躁轻率的形象登场，到了第三季中被Mind Flayer<sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="比利·哈格里夫: 片中角色，麦克斯的继兄，第二季登场，第三季牺牲。">[11]</span></a></sup>附身的他在剧末时被Eleven唤醒自己幼时的记忆，也解释了他如今性格的内因，最后以自我牺牲的方式救下了Eleven。从本次的预告来看，Billy的继妹Max<sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="麦克斯·哈格里夫: 比利的继妹，第二季登场，本季会有更多镜头。">[12]</span></a></sup>也将在本季有更多的戏份来完善她的个人形象，同时Eleven也将更进一步揭开她作为实验体的过去。<img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/13/164531.jpg" alt="Max"></p><p>本次预告让我惊艳的还有很多，80年代风格的Disco舞厅，重金属的背景音乐，重新出现的Lab负责人等等不再一一描述，我相信，单是预告片就足以让我惊艳的《怪奇物语》第四季必定会成为新的剧神。</p><p>PS:</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/13/172142.jpg" alt="这不屠杀吗？？？"></p><h3 id="注">注</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">霍金斯: 前三季故事的主要发生地。(另:本文其他剧集相关词汇均使用原名,注释会做解释)<a href="#fnref:0" rev="footnote"> ↩</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">中文字幕版 <a href="https://weibo.com/tv/show/1034:4757728514736336">https://weibo.com/tv/show/1034:4757728514736336</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">十一: 女主，拥有使用意念操控物体的能力<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">俄国: 毕竟设定是80年代的美国，反派懂得都懂<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">霍珀: 霍金斯局长，第二季收养了十一，第三季剧中被认为牺牲，但片尾彩蛋暗示了其被俄国俘获<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">魔王: 源自于主角团玩的DND，是颠倒世界的怪物<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">颠倒世界: 存在于另一个位面，在霍金斯有入口<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">杜夫兄弟: 《怪奇物语》的主创<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">霍金斯实验室: 曾经十一被作为实验体囚禁在这里，同时也存在进入颠倒世界的入口<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">克里尔之屋: 位于霍金斯，过去在这里有灵异事件发生<a href="#fnref:9" rev="footnote"> ↩</a></span></li><li id="fn:10"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">约瑟夫·哈灵顿: 片中角色，本次预告中再次与留在霍金斯的角色一起进入克里尔之屋<a href="#fnref:10" rev="footnote"> ↩</a></span></li><li id="fn:11"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">比利·哈格里夫: 片中角色，麦克斯的继兄，第二季登场，第三季牺牲。<a href="#fnref:11" rev="footnote"> ↩</a></span></li><li id="fn:12"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">麦克斯·哈格里夫: 比利的继妹，第二季登场，本季会有更多镜头。<a href="#fnref:12" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剧集 </tag>
            
            <tag> 怪奇物语 </tag>
            
            <tag> 预告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL(一) string</title>
      <link href="/posts/56391/"/>
      <url>/posts/56391/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="string容器基本概念">string容器基本概念</h2><p>C++标准库在头文件<string>中定义了string类，以满足char*难以使用的问题。</p><p>string和char* 的对比：</p><ul><li><p><strong style="color:#12aa9c;">char* 是一个指针，string是一个类</strong></p><p>string封装了char*，管理这个字符串，是char*型的容器。</p></li><li><p><strong style="color:#12aa9c;">string封装了很多成员方法</strong></p><p>find()查找，copy()拷贝，delete()删除，insert()插入</p></li><li><p><strong style="color:#12aa9c;">不用考虑内存的释放和越界</strong></p><p>string管理char*所分配的内存，每一次string的复制，取值都是由string类维护，不用担心复制越界和取值越界。</p></li></ul><h2 id="string容器常用方法">string容器常用方法</h2><h3 id="构造函数">构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">// string()</span></span><br><span class="line">  string s0; <span class="comment">// 空字符串构造</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// string(const char* s)</span></span><br><span class="line">  <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;this_is_a_string&quot;</span>)</span></span>; <span class="comment">// 从c字符数组复制</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// string(size_t n, char c)</span></span><br><span class="line">  <span class="function">string <span class="title">s2</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;s&#x27;</span>)</span></span>; <span class="comment">// 重复填充n个c组成字符串</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// string(congst string&amp; str)</span></span><br><span class="line">  <span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">// 从str复制</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// string(const char* s, size_t n)</span></span><br><span class="line">  <span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;this_is_a_string&quot;</span>, <span class="number">5</span>)</span></span>; <span class="comment">//从c字符数组头复制n个字符 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// string(const string&amp; str, size_t pos, size_t len = npos)</span></span><br><span class="line">  <span class="function">string <span class="title">s5</span><span class="params">(s1, <span class="number">2</span>, <span class="number">12</span>)</span></span>; <span class="comment">// 从str的pos开始复制，长度为len，若len太长或留空则截止到str尾</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// string(InputIterator first, InputIterator last)</span></span><br><span class="line">  <span class="function">string <span class="title">s6</span><span class="params">(s1.begin()+<span class="number">2</span>, s1.end()<span class="number">-1</span>)</span></span>; <span class="comment">// 复制[first, last)范围内的字符序列，first和last都是迭代器</span></span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;s0: &quot;</span>&lt;&lt;s0&lt;&lt;<span class="string">&quot;\ns1: &quot;</span>&lt;&lt;s1&lt;&lt;<span class="string">&quot;\ns2: &quot;</span>&lt;&lt;s2&lt;&lt;<span class="string">&quot;\ns3: &quot;</span>&lt;&lt;s3&lt;&lt;<span class="string">&quot;\ns4: &quot;</span>&lt;&lt;s4&lt;&lt;<span class="string">&quot;\ns5: &quot;</span>&lt;&lt;s5&lt;&lt;<span class="string">&quot;\ns6: &quot;</span>&lt;&lt;s6&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">  *  s0:       </span></span><br><span class="line"><span class="comment">  *  s1: this_is_a_string</span></span><br><span class="line"><span class="comment">  *  s2: ssssssssss</span></span><br><span class="line"><span class="comment">  *  s3: ssssssssss</span></span><br><span class="line"><span class="comment">  *  s4: this_</span></span><br><span class="line"><span class="comment">  *  s5: is_is_a_stri</span></span><br><span class="line"><span class="comment">  *  s6: is_is_a_strin</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="赋值">赋值</h3><p>这里提到的赋值，指的是<code>operator=</code>和<code>assign</code>，他们在作用上大同小异，唯一区别点就在于前者更加直观简洁，后者功能性更强，如下例中的<code>assign(size_type n, char c)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line">  <span class="comment">// operator= (const char* s)</span></span><br><span class="line">  s0 = <span class="string">&quot;this_is_a_string_too&quot;</span>; <span class="comment">// 从c字符数组赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// operator= (char c)</span></span><br><span class="line">  s1 = <span class="string">&#x27;s&#x27;</span>; <span class="comment">// 从字符赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// operator= (const string&amp; str)</span></span><br><span class="line">  s2 = s0 + s1; <span class="comment">//从str赋值</span></span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;s2: &quot;</span>&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">  <span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">  *  s2: this_is_a_string_toos</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  s1.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;s1: &quot;</span>&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">  <span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">  *  s1: ssssssssss</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="容量">容量</h3><p>这里主要是比较了几个修改<code>string</code>容量的函数的效果</p><p>为方便起见，<code>str.capacity()</code>称为容量；<code>str.size()</code>和<code>str.length()</code>称为长度；<code>str.max_size()</code>称为最大长度</p><ul><li><code>shrink_to_fit()</code> 修改容量到长度</li><li><code>resize()</code>直接修改长度，不影响容量</li><li><code>clear()</code>清空长度，不影响容量</li><li><code>reverse()</code>表示预留容量，只能扩大无法缩小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容量</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//shrink_to_fit</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.size() = &quot;</span>&lt;&lt;s0.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.length() = &quot;</span>&lt;&lt;s0.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.max_size() = &quot;</span>&lt;&lt;s0.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.capacity() = &quot;</span>&lt;&lt;s0.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s0.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.size() = &quot;</span>&lt;&lt;s0.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.length() = &quot;</span>&lt;&lt;s0.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.max_size() = &quot;</span>&lt;&lt;s0.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s0.capacity() = &quot;</span>&lt;&lt;s0.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// s0.size() = 20</span></span><br><span class="line">    <span class="comment">// s0.length() = 20</span></span><br><span class="line">    <span class="comment">// s0.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s0.capacity() = 30</span></span><br><span class="line">    <span class="comment">// s0.size() = 20</span></span><br><span class="line">    <span class="comment">// s0.length() = 20</span></span><br><span class="line">    <span class="comment">// s0.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s0.capacity() = 20    </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//resize</span></span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.size() = &quot;</span>&lt;&lt;s2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.length() = &quot;</span>&lt;&lt;s2.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.max_size() = &quot;</span>&lt;&lt;s2.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.capacity() = &quot;</span>&lt;&lt;s2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s2.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.size() = &quot;</span>&lt;&lt;s2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.length() = &quot;</span>&lt;&lt;s2.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.max_size() = &quot;</span>&lt;&lt;s2.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s2.capacity() = &quot;</span>&lt;&lt;s2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// this_is_a_string_toos</span></span><br><span class="line">    <span class="comment">// s2.size() = 21</span></span><br><span class="line">    <span class="comment">// s2.length() = 21</span></span><br><span class="line">    <span class="comment">// s2.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s2.capacity() = 40</span></span><br><span class="line">    <span class="comment">// this_is_a_</span></span><br><span class="line">    <span class="comment">// s2.size() = 10</span></span><br><span class="line">    <span class="comment">// s2.length() = 10</span></span><br><span class="line">    <span class="comment">// s2.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s2.capacity() = 40</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//clear()</span></span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">int</span>(s3.<span class="built_in">empty</span>())&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.size() = &quot;</span>&lt;&lt;s3.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.length() = &quot;</span>&lt;&lt;s3.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.max_size() = &quot;</span>&lt;&lt;s3.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.capacity() = &quot;</span>&lt;&lt;s3.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s3.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">int</span>(s3.<span class="built_in">empty</span>())&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.size() = &quot;</span>&lt;&lt;s3.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.length() = &quot;</span>&lt;&lt;s3.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.max_size() = &quot;</span>&lt;&lt;s3.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s3.capacity() = &quot;</span>&lt;&lt;s3.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// ssssssssss 0</span></span><br><span class="line">    <span class="comment">// s3.size() = 10</span></span><br><span class="line">    <span class="comment">// s3.length() = 10</span></span><br><span class="line">    <span class="comment">// s3.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s3.capacity() = 15</span></span><br><span class="line">    <span class="comment">//  1</span></span><br><span class="line">    <span class="comment">// s3.size() = 0</span></span><br><span class="line">    <span class="comment">// s3.length() = 0</span></span><br><span class="line">    <span class="comment">// s3.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s3.capacity() = 15</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//reserve</span></span><br><span class="line">    string s7;</span><br><span class="line">    s7.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">    s7 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.size() = &quot;</span>&lt;&lt;s7.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.length() = &quot;</span>&lt;&lt;s7.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.max_size() = &quot;</span>&lt;&lt;s7.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.capacity() = &quot;</span>&lt;&lt;s7.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    s7.<span class="built_in">reserve</span>(<span class="number">30</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.size() = &quot;</span>&lt;&lt;s7.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.length() = &quot;</span>&lt;&lt;s7.<span class="built_in">length</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.max_size() = &quot;</span>&lt;&lt;s7.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;s7.capacity() = &quot;</span>&lt;&lt;s7.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="comment">// s7.size() = 10</span></span><br><span class="line">    <span class="comment">// s7.length() = 10</span></span><br><span class="line">    <span class="comment">// s7.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s7.capacity() = 30</span></span><br><span class="line">    <span class="comment">// s7.size() = 10</span></span><br><span class="line">    <span class="comment">// s7.length() = 10</span></span><br><span class="line">    <span class="comment">// s7.max_size() = 9223372036854775807</span></span><br><span class="line">    <span class="comment">// s7.capacity() = 15</span></span><br></pre></td></tr></table></figure><h3 id="访问">访问</h3><p>用于访问<code>string</code>中的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问</span></span><br><span class="line">  <span class="function">string <span class="title">s8</span><span class="params">(<span class="string">&quot;abcdefghijklmn&quot;</span>)</span></span>;</span><br><span class="line">  cout&lt;&lt;s8[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s8.<span class="built_in">at</span>(<span class="number">2</span>)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s8.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s8.<span class="built_in">back</span>()&lt;&lt;endl;</span><br><span class="line">  <span class="comment">// 输出结果 b c a n</span></span><br></pre></td></tr></table></figure><h3 id="修改">修改</h3><p>这里涉及到的方法比较多，后续会精讲一部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line">  cout&lt;&lt;(s8 += <span class="string">&quot;op&quot;</span>)&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;s8.<span class="built_in">append</span>(<span class="string">&quot;st&quot;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  s8.<span class="built_in">push_back</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">  cout&lt;&lt;s8&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  cout&lt;&lt;s8.<span class="built_in">insert</span>(<span class="number">16</span>, <span class="string">&quot;qr&quot;</span>)&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;s8.<span class="built_in">erase</span>(s8.<span class="built_in">size</span>()<span class="number">-1</span>, <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;s8.<span class="built_in">replace</span>(s8.<span class="built_in">end</span>()<span class="number">-1</span>, s8.<span class="built_in">end</span>(), <span class="string">&quot;tuv&quot;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  s8.<span class="built_in">pop_back</span>();</span><br><span class="line">  cout&lt;&lt;s8&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  string s9 = <span class="string">&quot;vwxyz&quot;</span>;</span><br><span class="line">  s8.<span class="built_in">swap</span>(s9);</span><br><span class="line">  cout&lt;&lt;s8&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s9&lt;&lt;endl;</span><br><span class="line">  <span class="comment">// 输出结果</span></span><br><span class="line">  <span class="comment">// abcdefghijklmnop</span></span><br><span class="line">  <span class="comment">// abcdefghijklmnopst</span></span><br><span class="line">  <span class="comment">// abcdefghijklmnopstu</span></span><br><span class="line">  <span class="comment">// abcdefghijklmnopqrstu</span></span><br><span class="line">  <span class="comment">// abcdefghijklmnopqrst</span></span><br><span class="line">  <span class="comment">// abcdefghijklmnopqrstuv</span></span><br><span class="line">  <span class="comment">// abcdefghijklmnopqrstu</span></span><br><span class="line">  <span class="comment">// vwxyz abcdefghijklmnopqrstu</span></span><br></pre></td></tr></table></figure><h3 id="其他操作">其他操作</h3><p><code>data()</code>可以返回str的字符数组指针，<code>substr(size_type n, size_type len = npos)</code>返回从str截取的，起点为n，长度为len的子串。（关于len的默认值可参考s5的构造函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他操作</span></span><br><span class="line">  cout&lt;&lt;s9.<span class="built_in">data</span>()+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;s9.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 输出结果</span></span><br><span class="line">  <span class="comment">// bcdefghijklmnopqrstu</span></span><br><span class="line">  <span class="comment">// bcd</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> C++ STL系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++排序</title>
      <link href="/posts/2188/"/>
      <url>/posts/2188/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1>常用排序</h1><blockquote><center style="color:#C0C0C0">所有算法均为C++，实现了各类排序的基本功能</center></blockquote><h2 id="算法概述">算法概述</h2><h3 id="算法分类">算法分类</h3><p>常见的排序算法可以分为一下两大类：</p><ul><li><strong>非线性时间比较类</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</li><li><strong>线性时间非比较类</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/03/29/142345.png" alt=""></p><h3 id="时间复杂度比较">时间复杂度比较</h3><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/03/29/142535.png" alt=""></p><center style="color:#C0C0C0">仅供参考</center><h3 id="相关概念">相关概念</h3><p><span style="background:#FFDBBB;">稳定</span>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</p><p><span style="background:#FFDBBB;">不稳定</span>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</p><p><span style="background:#FF9999;">时间复杂度</span>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</p><p><span style="background:#FF9999;">空间复杂度</span>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</p><h2 id="快速排序-quickSort">快速排序 quickSort()</h2><h3 id="算法描述">算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）。</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3 id="具体实现">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回条件，如果vec为空或者左右指针位置相同或相反则返回</span></span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取随机位置首先与作比较值的元素交换，防止有序序列引起的效率低下</span></span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">unsigned</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="type">int</span> temp = <span class="built_in">rand</span>()%(right-left+<span class="number">1</span>)+left;</span><br><span class="line">    <span class="built_in">swap</span>((*vec)[left], (*vec)[temp]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化，存储vec[left]作为比较值以及left和right</span></span><br><span class="line">    <span class="type">int</span> key = (*vec)[left],  i = left, j = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主循环</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="comment">//首先右指针向左找到第一个小于比较值的元素vec[j]</span></span><br><span class="line">        <span class="comment">//找到后将i指向的元素改为vec[j]</span></span><br><span class="line">        <span class="comment">//接着左指针向右找到第一个大于比较值的元素vec[i]</span></span><br><span class="line">        <span class="comment">//找到后将j指向的元素改为vec[i]</span></span><br><span class="line">        <span class="comment">//直到i和j相遇</span></span><br><span class="line">        <span class="keyword">while</span>((*vec)[j] &gt; key &amp;&amp; i &lt; j) j--;</span><br><span class="line">        (*vec)[i] = (*vec)[j];</span><br><span class="line">        <span class="keyword">while</span>((*vec)[i] &lt;= key &amp;&amp; i &lt; j) i++;</span><br><span class="line">        (*vec)[j] = (*vec)[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出时i和j应该是同一个位置，此时将key放在此位置</span></span><br><span class="line">    (*vec)[i] = key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归对左右两部分进行quickSort()</span></span><br><span class="line">    <span class="built_in">quickSort</span>(vec, left, i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec, j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序-bubbleSort">冒泡排序 bubbleSort()</h2><h3 id="算法描述-2">算法描述</h3><p>冒泡排序是稳定排序</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h3 id="具体实现-2">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环遍历，比较相邻元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; vec-&gt;<span class="built_in">size</span>()<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((*vec)[j] &gt;= (*vec)[j+<span class="number">1</span>]) <span class="built_in">swap</span>((*vec)[j], (*vec)[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序-shellSort">希尔排序 shellSort()</h2><h3 id="算法描述-3">算法描述</h3><p><span style="background:#FF9999;">希尔排序是<a href="#insertionSort">插入排序</a>的优化版，但不是稳定排序</span></p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mn>1</mn><mtext>，</mtext><mi>t</mi><mn>2</mn><mtext>，</mtext><mo>…</mo><mtext>，</mtext><mi>t</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">t1，t2，…，tk</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi><mo>&gt;</mo><mi>t</mi><mi>j</mi><mtext>，</mtext><mi>t</mi><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ti&gt;tj，tk=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>；</li><li>按增量序列个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，对序列进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>趟排序；</li><li>每趟排序，根据对应的增量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ti</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span></span></span></span>，将待排序列分割成若干长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>的子序列，分别对各子表进行直接插入排序。仅增量因子为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="具体实现-3">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec, <span class="type">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//与插入排序相比多了步长的条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; step; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = step + k; i &lt; vec-&gt;<span class="built_in">size</span>(); i += step)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt; k; j -= step)&#123;</span><br><span class="line">                <span class="keyword">if</span>((*vec)[j] &lt;= (*vec)[j - step]) <span class="built_in">swap</span>((*vec)[j], (*vec)[j - step]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//步长减半，递归执行</span></span><br><span class="line">    <span class="built_in">shellSort</span>(vec, step/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="insertionSort"></a></p><h2 id="插入排序-insertSort">插入排序 insertSort()</h2><h3 id="算法描述-4">算法描述</h3><p>直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下：</p><ul><li>对于一个数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>的排序问题，假设认为数组在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>排序的问题已经解决了。</li><li>考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>的值，从右向左扫描有序数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0,n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，直到第一个小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>的元素，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>插在这个元素的后面。</li></ul><p>很显然，基于增量法的思想在解决这个问题上拥有更高的效率。</p><p>直接插入排序对于最坏情况（严格递减的数组），需要比较和移位的次数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>；对于最好的情况（严格递增的数组），需要比较的次数是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，需要移位的次数是0。当然，对于最好和最坏的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序）。直接插入排序的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，同时也是稳定排序。</p><h3 id="具体实现-4">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环遍历，满足条件就前插</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec-&gt;<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((*vec)[j] &lt; (*vec)[j<span class="number">-1</span>]) <span class="built_in">swap</span>((*vec)[j], (*vec)[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序-heapSort">堆排序 heapSort()</h2><h3 id="算法描述-5">算法描述</h3><p>堆排序实际上是利用堆的性质来进行排序的，要知道堆排序的原理首先一定要知道什么是堆<br>堆的定义：<br>堆实际上是一棵完全二叉树。<br>堆满足两个性质:</p><ol><li>堆的每一个父节点都大于（或小于）其子节点。</li><li>堆的每个左子树和右子树也是一个堆。</li></ol><p>堆分为两类：</p><ol><li><p>最大堆（大根堆）：堆的每个父节点都大于其孩子节点。</p></li><li><p>最小堆（小根堆）：堆的每个父节点都小于其孩子节点。</p></li></ol><p>堆的存储：<br>一般都用数组来表示堆，i结点的父结点下标就为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mtext>–</mtext><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(i – 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord">–1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span>，它的左右子结点下标分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>1</mn><mtext>和</mtext><mn>2</mn><mo>∗</mo><mi>i</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2 *i + 1和2* i + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">和</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/03/29/185022.png" alt=""></p><p>根据堆的性质可知，堆顶的元素要么是最大值，要么是最小值。则在排序的时候可以利用这个性质，将第一个元素与最后一个元素交换，接着调整堆的前<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个元素（假设原来有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个元素），之后重复这个步骤即可。</p><h3 id="具体实现-5">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整堆（大根堆），从上往下调整，传入堆指针vec, 调整位置adj， 调整长度len</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec, <span class="type">int</span> adj, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存储左孩子</span></span><br><span class="line">    <span class="type">int</span> child = adj * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自上而下</span></span><br><span class="line">    <span class="keyword">while</span>(child &lt; len)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当存在右孩子且右孩子比左孩子大时，child改为右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt; len &amp;&amp; (*vec)[child] &lt; (*vec)[child + <span class="number">1</span>]) child++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果调整结点更大则说明不需要调整，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>((*vec)[adj] &gt;= (*vec)[child]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行调整，交换调整结点和孩子结点</span></span><br><span class="line">        <span class="built_in">swap</span>((*vec)[adj], (*vec)[child]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将调整结点赋为孩子结点，孩子结点赋为修改后的调整结点的左孩子</span></span><br><span class="line">        adj = child;</span><br><span class="line">        child = adj * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆，传入待建堆（用vector表示堆）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从最后一个非叶子结点开始，循环向上执行adjustHeap()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = vec-&gt;<span class="built_in">size</span>()/<span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(vec, i, vec-&gt;<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序，传入待排序vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先建堆</span></span><br><span class="line">    <span class="built_in">makeHeap</span>(vec);</span><br><span class="line">    <span class="type">int</span> len = vec-&gt;<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从最后一个结点开始，每次先将堆顶与其交换，接着调整除最后一个结点外的堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>((*vec)[<span class="number">0</span>], (*vec)[i]);</span><br><span class="line">        <span class="built_in">adjustHeap</span>(vec, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序-selectSort">选择排序 selectSort()</h2><h3 id="算法描述-6">算法描述</h3><p>与堆排序一样，选择排序也可以一次将一个元素送到最终位置，其工作原理很容易理解：</p><ol><li>在序列中找到最小元素，放到序列的起始位置，作为已排序部分。</li><li>在未排序部分找到最小元素，放到已排序部分的末尾，重复第二步，直到所有元素均处于已排序部分。</li></ol><h3 id="具体实现-6">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec-&gt;<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; vec-&gt;<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            min = (*vec)[j] &lt; (*vec)[min] ? j : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>((*vec)[min], (*vec)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-mergeSort">归并排序 mergeSort()</h2><h3 id="算法描述-7">算法描述</h3><p>归并排序是利用分治的思想将问题分成一些小的子问题递归求解，其算法步骤可分为：</p><ol><li>申请空间，大小为两个已排序序列之和，用于存放合并后的序列</li><li>设定两个指针，最初位置分别是两个已排序序列的起始位置</li><li>比较元素，选择小值放入合并序列，并移动指针到下一个位置，重复该步骤直到某一指针到序列尾</li><li>另一序列剩下的元素直接复制到合并序列尾。</li></ol><h3 id="具体实现-7">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftSubVector</span><span class="params">(vec-&gt;begin() + left, vec-&gt;begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSubVector</span><span class="params">(vec-&gt;begin() + mid + <span class="number">1</span>, vec-&gt;begin() + right + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idLeft = <span class="number">0</span>, idRight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    leftSubVector.<span class="built_in">insert</span>(leftSubVector.<span class="built_in">end</span>(), INT_MAX);</span><br><span class="line">    rightSubVector.<span class="built_in">insert</span>(rightSubVector.<span class="built_in">end</span>(), INT_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(leftSubVector[idLeft] &lt; rightSubVector[idRight])&#123;</span><br><span class="line">            (*vec)[i] = leftSubVector[idLeft];</span><br><span class="line">            idLeft++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            (*vec)[i] = rightSubVector[idRight];</span><br><span class="line">            idRight++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(vec, left, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(vec, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">merge</span>(vec, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序-radixSort">基数排序 radixSort()</h2><h3 id="算法描述-8">算法描述</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>基数排序借助额外的空间（存储0~9各自出现的次数以及临时排序的<code>vector</code>）进行排序，使得效率可以达到线性时间复杂度。</p><h3 id="具体实现-8">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大位数</span></span><br><span class="line">    <span class="type">int</span> bit = <span class="built_in">maxBit</span>(vec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//count用于存储基数出现的次数，temp用于临时存储当次基数排序结果</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(vec-&gt;size())</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代bit次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= bit; i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//count清零</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) count[j] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//count计数</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; vec-&gt;<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            k = ((*vec)[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对所有计数累加，方便后面temp存储，count[j]此时表示前面一共多少个位置</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) count[j] += count[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒序遍历vec，并将结果保存在temp中，此时即为按基数排序状态</span></span><br><span class="line">        <span class="keyword">for</span>(j = vec-&gt;<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            k = ((*vec)[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里存放的位置就是当位的最后一个位置</span></span><br><span class="line">            <span class="comment">//因为count是表示0~9，所以temp中的结果应该是按照基数从大到小的</span></span><br><span class="line">            <span class="comment">//这样比完一轮后，后面赋回vec，进行下一轮时上次的基数大值应该同样在基数小值前面</span></span><br><span class="line">            <span class="comment">//即插入当位的最后一个位置</span></span><br><span class="line">            temp[count[k] - <span class="number">1</span>] = (*vec)[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//temp赋回vec</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; vec-&gt;<span class="built_in">size</span>(); j++) (*vec)[j] = temp[j];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提一位</span></span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序-countSort">计数排序 countSort()</h2><h3 id="算法描述-9">算法描述</h3><p>计数排序有点类似基数排序~~（甚至名字都差不多）~~，都是基于额外的空间完成，达到线性的时间复杂度。</p><p>计数排序直接存储唯一键值，通过统计键值出现的次数，最后排序。这也要求了数据范围尽量小且重复度较高，否则会浪费空间。</p><p>算法步骤如下：</p><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的元素出现的次数，存入<code>vector C</code>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>项</li><li>对所有的计数累加（从<code>vector C</code>中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>放在新数组的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">C[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>项，每放一个元素就将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">C[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>减去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li></ol><h3 id="具体实现-9">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxData = (*vec)[<span class="number">0</span>], i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; vec-&gt;<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxData &lt; (*vec)[i]) maxData = (*vec)[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxData+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(*vec)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: *vec)&#123;</span><br><span class="line">        count[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= maxData; i++) count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = vec-&gt;<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        (*vec)[count[temp[i]]] = temp[i];</span><br><span class="line">        count[temp[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="桶排序-bucketSort">桶排序 bucketSort()</h2><h3 id="算法描述-10">算法描述</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序。（有可能再使用别的排序算法或是以递归方式继续使用桶排序）</p><p>假设有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个数字，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>个桶，如果数字是平均分布的，则每个桶里面平均有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>×</mo><mfrac><mi>n</mi><mi>m</mi></mfrac><mo>×</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mfrac><mi>n</mi><mi>m</mi></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mtext>–</mtext><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m \times \frac{n}{m} \times log_2(\frac{n}{m})) = O(n + nlog_2n – nlog_2m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mord">–</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>趋近于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>时，最佳的时间复杂度可以达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h3 id="具体实现-10">具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(list&lt;<span class="type">int</span>&gt;&amp; bucket, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = bucket.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != bucket.<span class="built_in">end</span>() &amp;&amp; val &gt;= *iter) ++iter;</span><br><span class="line">    bucket.<span class="built_in">insert</span>(iter, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;* vec)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(vec-&gt;<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = vec-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> minData = (*vec)[<span class="number">0</span>], maxData = minData, i = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(minData &gt; (*vec)[i]) minData = (*vec)[i];</span><br><span class="line">        <span class="keyword">if</span>(maxData &lt; (*vec)[i]) maxData = (*vec)[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> bucketNum = (maxData - minData) / k + <span class="number">1</span>;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">insert</span>(buckets[((*vec)[i] - minData) / k], (*vec)[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(buckets[i].<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; val: buckets[i]) (*vec)[index++] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于桶排序">关于桶排序</h3><p><span style="background:#FF9999;">基数排序</span>，<span style="background:#FF9999;">计数排序</span>和<span style="background:#FF9999;">桶排序</span>都是通过利用<span style="background:#bbffff;">额外的空间</span>辅助来达到线性时间复杂度的，这种额外的空间称为桶，也就是说，这三种排序方法都用到了桶，只不过桶的功能有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个文章</title>
      <link href="/posts/64720/"/>
      <url>/posts/64720/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="第一个文章测试">第一个文章测试</h2><p>成功搭建hexo博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
