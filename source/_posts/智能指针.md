---
title: 智能指针
tags:
  - C++
  - 指针
  - 内存
categories: 学习
top_img: 'https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/22/211645.jpg'
abbrlink: 47718
date: 2022-04-22 21:12:07
---

## 智能指针的原理和作用

### 智能指针的作用

在C++中，指针的使用离不开内存管理的知识(参见“指针和引用”)，内存管理又离不开堆和栈。其中栈由编译器自动管理，而堆需要程序员手动管理。在普通指针的使用过程中，经常需要申请释放堆内存，稍有不慎就会导致内存泄漏或者程序崩溃。智能指针就是为了更好地管理堆内存，解决手动管理堆内存容易产生的内存泄漏等问题。

### 智能指针的原理

1. 从较浅的层面看，智能指针是利用了一种叫做RAII（见下文）的思想对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。
2. 智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。
3. 智能指针还有一个作用是把值语义转换成对象语义。

> 关于值语义和对象语义，你可以简单的理解为值语义相当于一个东西的属性和另一个东西的属性完全一样，但其实这是两个东西。而对象语义相当于一个东西的属性和另一个东西的属性完全一样，这其实是一个东西。C++的语法其实是值语义的，但面向对象却需要对象语义来解释，这就是C++中面向对象容易产生BUG的根源。更详细的解释，请移步[这篇大佬的文章](http://www.cnblogs.com/Solstice/archive/2011/08/16/2141515.html)。

### RAII编程思想

关于RAII编程思想参考了这篇文章:[C++ —— RAII编程思想](https://blog.csdn.net/noahzuo/article/details/51139940)

#### Class的构建和析构

C++相比C多了面向对象，面向对象的核心是一个一个Class，而Class的核心是构造函数和析构函数。

在C++中，如果Class的对象声明在栈，则当其生命周期结束后Class会自动调用析构函数将对象删除，但如果Class的对象声明在堆中(使用new或malloc方法)，则需要显示地调用析构函数才能进行析构。

#### RAII

RAII，即"Resource Aquisition Is Initialization"(资源获取即初始化)。RAII的思想很简单，就是<span style="background:#FF9999;">利用C++对象的生命周期来控制资源的获取释放</span>。简单来说，就是当程序员希望对某个资源进行管理，那么创建一个对象，并将资源的生命周期和对象的生命周期相关联，这时C++自带的对象管理就可以管理该资源。例子如下：

```c++
class Resource{...}; // 需要控制的资源
class ResourceHandle{ // 管理类
    public:
         // 获取资源
         explicit ResourceHandle(ResourceHandle *aResource ): r_(aResource){}

         // 释放资源
         ~ResourceHandle()
         {
             delete r_;
         }

         // 获取资源获取权限
         Resource *get()
         {
             return r_;
         }

    private:
        // 确保资源不会被拷贝
        ResourceHandle (const ResourceHandle &);
        ResourceHandle & operator = (const ResourceHandle &);
        Resource *r_;
    };
```

ResoueceHandle类就是一个管理资源的类，一个ResourceHandle的对象如果被声明为一个函数的局部变量，或者作为一个参数或静态变量，都可以保证析构函数被调用，即该对象引用的资源被释放。

再来看一个反例：

```c++
void f() {
    Resource *rh = new Resource;
    //...
    if (blahblah())
         return ;    
    //...
    g();         //触发异常

    // 能确保它可以在这里被处理吗？
    delete rh ;
}
```

如果我们使用普通的指针去指向一个堆内存，虽然加上了使用过后释放该内存的语句，但如上例所描述的那样，如果在`g()`函数调用过程中触发了异常导致程序崩溃，还能确保`delete rh`能够被执行，其所指的内存被释放吗？

如果利用上述的RAII思想对其进行改进，则结果如下：

```c++
void f() {
    ResourceHandle rh (new Resource); //创建ResoueceHandle类的对象获取资源

    // ...
    if (blahblah())
         return ;

    // 这里即使仍然触发异常
    g();

    // 最终仍会被析构函数释放
    }
```

如此，RAII使得代码更加健壮。但RAII仍有一种情况无法保证析构函数被调用，这就是当ResourceHandle对象被动态分配到堆内存上，这时仍然需要显式调用析构函数才能保证资源被释放。

```c++
ResourceHandle *rhp = new ResourceHandle(new Resource);

//其实质还是使用了普通的指针，只不过指向的不是原有的资源，而是资源管理对象。
```

## 智能指针的使用

以C++11为准，智能指针有三类，分别为`shared_ptr`，`unique_ptr`，`weak_ptr`，其头文件为<memory>。


### `unique_ptr`

`unique_ptr`"唯一"占有其所指的对象。`unique_ptr`只有move方法而没有赋值和拷贝的方法，这意味着同一时刻只能有一个对象被`unique_ptr`所指。

`unique_ptr`的生命周期为从创建`unique_ptr`指针开始，直到离开作用域。在`unique_ptr`的生命周期内，可以改变`unique_ptr`所指的对象（创建`unique_ptr`通过构造函数指定，通过`reset`方法重新指定，通过`release`方法释放所有权，通过`move`方法转移所有权）

```c++
int main(){

    unique_ptr<int> ptr(new int(10)); //从构造函数绑定对象

    // unique_ptr<int> ptr1 = ptr; 报错，不能赋值
    // unique_ptr<int> ptr2(ptr); 报错，不能拷贝

    unique_ptr<int> ptr3(new int(20));
    // ptr3.reset(ptr.get()); 编译报错，下面还有一条一样的语句

    unique_ptr<int> ptr4 = move(ptr); //转移所有权
    ptr3.reset(ptr.get()); //这次不报错
    // 因为在上面ptr所指的资源已经绑定了Ptr，所以通过reset重新指定Ptr3绑定的资源会与ptr重复
    // 而通过move方法将ptr所有权转移给Ptr4之后，ptr此时被释放了，其原始指针为nullptr
    
    if(ptr3.get() == nullptr){cout<<"null"<<endl;} 
    //验证ptr3 reset之后原始指针也为nullptr

    ptr4.release(); //释放所有权
}
```

### `shared_ptr`

`shared_ptr`可以使多个指针指向同一个对象，每一个拷贝都指向相同的内存。shared_ptr使用引用计数，每使用一次内部引用计数+1，析构一次引用计数-1，减到0后自动删除指向的堆内存。`shared_ptr`内部的引用计数是线程安全的，但读取时要加锁。

`shared_ptr`并不是完美的，容易出现[循环引用](#circularReference)的问题，这一问题会在介绍完`weak_ptr`之后介绍。

```c++
int main(){

    int a = 10; //定义整型变量
    int* pa = &a; //定义指针

    shared_ptr<int> ptr1 = make_shared<int>(a);
    shared_ptr<int> ptr2 = make_shared<int>(*pa);
    // 通过make_shared方法定义创建shared_ptr对象

    // shared_ptr<int> ptr3 = &a;
    // shared_ptr<int> ptr4 = pa;
    // 错误，shared_ptr本质是类，而&a和pa是指针

    shared_ptr<int> ptr5(new int(10));
    shared_ptr<int> ptr6(new int(a));
    shared_ptr<int> ptr7(ptr6);
    // 通过构造函数创建shared_ptr对象

    cout<<ptr1.use_count()<<endl;
    cout<<ptr2.use_count()<<endl;
    cout<<ptr5.use_count()<<endl;
    cout<<ptr6.use_count()<<endl;
    cout<<ptr7.use_count()<<endl;
    // 输出ptr1 2 5 6 7 的引用计数，为1 1 1 2 2，
    // 可以发现，虽然他们都指向的是一块值为10的内存空间，
    // 但其实通过值来创建shared_ptr对象是重新在堆中申请了一块内存空间的，并不指向原来的内存。
    // 而6 7的引用计数均为2，说明通过拷贝构造的share_ptr指向的是同一块内存空间。
    // 同时也可以得到拷贝会使引用计数+1。

    ptr7 = ptr5;
    cout<<ptr5.use_count()<<endl;
    cout<<ptr6.use_count()<<endl;
    cout<<ptr7.use_count()<<endl;
    // 把ptr5赋值给ptr7,
    // 再次输出ptr5 6 7 的引用计数，为2 1 2，
    // 则可以发现，赋值会使原引用计数-1(ptr6)，后引用计数+1(ptr5)。
    
    pa = ptr7.get() //通过get()获取原始指针。
        
    // 1. shared_ptr<int> ptr8(a);
    // 2. int* pb = new int(a);
    // 3. shared_ptr<int> ptr9(pb);
    // 4. shared_ptr<int> ptr10(pb);
    // 以上4条语句需要注意
    // 不要使用第一条语句的形式创建shared_ptr，shared_ptr对象应当由堆内存中创建。
    // 不要出现3 4语句的形式，即不要出现一个原始指针创建多个shared_ptr对象。
}
```

### `weak_ptr`

`weak_ptr`是为了配合`shared_ptr`而引入的一种智能指针，因为<span style="background:#FF9999;">它不具有普通指针的行为，没有重载operator*和-></span>。`weak_ptr`最大的作用在于<span style="background:#FF9999;">协助shared_ptr工作，像旁观者那样观测资源的使用情况</span>。

`weak_ptr`可以从一个`shared_ptr`或者另一个`weak_ptr`对象构造，获得资源的观测权。但`weak_ptr`没有共享资源，它的构造不会引起指针引用计数的增加。

使用`weak_ptr`的成员函数`use_count()`可以观测资源的引用计数，另一个成员函数`expired()`的功能等价于`use_count()==0`,但更快，表示被观测的资源(也就是`shared_ptr`的管理的资源)已经不复存在。

`weak_ptr`可以使用一个非常重要的成员函数`lock()`从被观测的shared_ptr获得一个可用的`shared_ptr`对象， 从而操作资源。但当`expired()==true`的时候，`lock()`函数将返回一个存储空指针的`shared_ptr`。

```c++
int main(){
    shared_ptr<int> ptr1 = make_shared<int>(10); // make_shared方法创建shared_ptr
    cout<<ptr1.use_count()<<endl; // 输出 1

    weak_ptr<int> ptr2(ptr1); // 通过构造函数从shared_ptr创建一个weak_ptr
    cout<<ptr1.use_count()<<endl; // 输出 1 weak_ptr不影响shared_ptr

    //调用weak_ptr的expired方法，检查观测目标是否指向nullptr
    if(!ptr2.expired()){

        //lock方法可以获得一个可用的被观测的share_ptr的对象
        shared_ptr<int> ptr3(ptr2.lock());
        *ptr3.get() = 100;
        cout<<ptr1.use_count()<<endl; //输出 2
    }
}
```
<a id="circularReference"></a>
### 循环引用

#### 问题产生

循环引用指的是当两个对象互相强引用对方(通过`shared_ptr`)，从而因为无法完成释放对象导致内存泄漏。

![](https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/22/205510.png)

这是由于`shared_ptr`使用引用计数，当引用计数为0时才调用析构函数从而释放内存。故脱离作用域后A需要等待B释放来使A的引用计数减为0，B同样需要等待A释放来使B的引用计数减为0，最终A B都无法释放导致内存泄漏。

来看一个简单的实现：

```c++
class B;
class A {
public:
    A() { 
        cout << "I'm A!" << endl; 
    }
    ~A() { 
        cout << "A: I'm free!" << endl; 
    }
    void Make(shared_ptr<B> pb) { 
        pb_ = pb; 
    }

private:
    shared_ptr<B> pb_; //指向一个B类的shared_ptr
};

class B {
public:
    B() { 
        cout << "I'm B!" << endl; 
    }
    ~B() { 
        cout << "B: I'm free!" << endl; 
    }
    void Make(shared_ptr<A> pa) { 
        pa_ = pa; 
    }

private:
    shared_ptr<A> pa_; // 指向一个A类的shared_ptr
};

int main(){
    shared_ptr<A> pta(new A()); // 此时pta引用计数为1
    shared_ptr<B> ptb(new B()); // 此时ptb引用计数为1
    {
        pta->Make(ptb); // 此时ptb引用计数为2
        ptb->Make(pta); // 此时pta引用计数为2
    }
}

//脱离作用域，pta和ptb引用计数都减为1

// 输出
// I'm A!
// I'm B!
```

可以看到脱离作用域后由于pta和ptb的引用计数都未减为0，A和B的析构函数均未被调用，出现内存泄漏。

#### 解决方案

循环引用的解决方案就是利用`weak_ptr`的弱引用性质实现的，将A B互相的强引用中其中一方变为弱引用，因为弱引用是不增加引用计数的，所以最终会使引用计数都减为0，从而调用析构函数释放内存。
