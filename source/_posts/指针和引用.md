---
title: 指针和引用
tags:
  - 指针
  - C++
  - 引用
categories: 学习
top_img: 'https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/20/161252.png'
abbrlink: 22647
date: 2022-04-20 16:08:35
---

C++中非常重要的一个工具就是强大灵活的指针，当然他的灵活也会导致一些琐碎的问题和细节上需要注意的事项，这篇就来整理一下指针的相关知识。

## 什么是指针

在C++中，定义了变量一般会在内存中随机分配一块地址，而指针则可以间接地访问到内存中的地址进行数据的读写。

由于指针与内存的联系十分紧密，要想理解指针，首先要从内存说起。

## 变量在内存中的存储

程序中定义了一个`int a = 1`，那么其在内存中的存储格式是这样的：

| ........ | ........ | ........ | 00000000 | 00000000 | 00000000 | 00000001 | ........ |
| :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: |
|          |          | 低地址   | 0028FF40 | 0028FF41 | 0028FF42 | 0028FF43 | 高地址   |

int类型占4个字节，其首地址表示占据内存的地址

用来保存指针的对象也是一种变量，如果定义一个指针int* p保存a的地址(即p指向a)，则其在内存中的存储是这样的：

| ........ | 0028FF40 | ........ | 00000000 | 00000000 | 00000000 | 00000001 | ........ |
| :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: |
|          | xxxxxxxx |          | 0028FF40 | 0028FF41 | 0028FF42 | 0028FF43 | 高地址   |

## 指针的基本使用

### 指针变量的定义

```c++
int* p_int;   //指向int类型变量的指针         

double* p_double;  //指向double类型变量的指针  
   
Student* p_struct;  //类或结构体类型的指针

int** p_pointer;  //指向 一个整形变量指针的指针

int(*p_arr)[3];  //指向含有3个int元素的数组的指针 
 
int(*p_func)(int,int);  //指向返回类型为int，有2个int形参的函数的指针  
```

### 指针变量的解析

```c++
int a = 10;
int *p = &a;
*p = 1000;

cout<<a<<endl;
```

### 指针的算数运算

指针可以通过加上或减去一个整数访问其他内存地址，其运算是根据指针的数据类型来执行的

```c++
int arr[5] = {1, 2, 3, 4, 5};
int *p1 = arr;

char str[5] = {'1', '2', '3', '4', '5'};
char* p2 = str;

cout<<*p1<<" "<<*(p1+1)<<endl; //1 2
cout<<*p2<<" "<<*(p2+1)<<endl; //1 2
```

上面例子可以看出虽然p1，p2都是加了1，但他们并不是都指向了原地址后一个字节的地址，而是根据不同的数据类型，乘以了`sizeof(type)`。

## 空指针和野指针

### 空指针

#### 空指针常量

一个表示0值的整数常量，叫做空指针常量。例如：0、0L、1-1（它们都是值为0的整数常量表达式）以及`(void*)0、void* NULL` 都是空指针常量，空指针常量可以赋值给任何指针类型，因为它是变体类型`（void*）`。但是我们更倾向于使用NULL表示这个空指针常量。对于其它方式（比如0）来表示空指针常量虽然不会产生任何问题，但是在根本意义上并不符合空指针常量的定义。因为空指针常量的存在意义还在强调它并不指向任何对象

#### 空指针

空指针不指向任何实际的对象或者函数。

空指针是一个特殊的指针，因为这个指针不指向任何地方。这意味任何一个有效的指针如果和空指针进行相等的比较运算时，结果都是false。

#### 空指针指向内存的什么地方

标准并没有对空指针指向内存中的什么地方这一问题作出规定，也就是说用哪个具体地址值表示空指针取决于系统实现。我们常见的空指针一般指向0地址，即空指针的内部用全0来表示。<span style="background:#FF9999;">这个地址没有实际的物理地址与之对应，所以访问这个地址会报空指针异常</span>。

### 野指针

野指针不是空指针，是一个指向非法内存空间的指针。

#### 野指针的产生原因

1. 指针变量没有初始化

任何指针变量被刚创建时不会被自动初始化为NULL指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。

2. 指针被delete或free后没有及时置空或指向其他有效地址

free和delete只是把指针所指向的内存给释放掉，但并没有把指针本身给清理掉。这时候的指针依然指向原来的位置，只不过这个位置的内存数据已经被毁尸灭迹，此时的这个指针指向的内存就是一个垃圾内存。

1. 指针超越变量作用范围

因为指针可以做算数运算，故可能会由于运算导致指针指向了变量以外的内存空间。另一种情况是函数返回了<span style="background:#FF9999;">非静态局部变量的地址</span>，因为该变量已经脱离了作用域而被系统销毁，此时接受返回值的指针就是一个野指针，示例如下：

```c++
int* test(int a, int b){
    int sum = a + b;
    int* p = &sum;
    return p; //不要返回临时变量的地址
}

int main (){
    int a = 10, b = 20;
    int *p = test(a, b);
    cout<<*p<<endl; 
    return 0;
}
```

## 函数和指针

<a id="functionParametersAndPointers"></a>

### 函数的参数和指针

实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。

当然可以通过返回值将修改后的参数返回，但当需要修改的参数不止一个，返回值就无能为力了，传递参数的指针就可以解决这个问题，指针传递的是参数的地址，当形参改变，实参也会跟着改变。

### 函数的返回值和指针

当函数的返回值是一个指针，那么可以称为指针函数，其本质是一个函数。

唯一需要注意的一点是上文提到的不要<span style="background:#FF9999;">返回非静态局部变量的地址</span>，会产生野指针。

### 函数的指针

即函数指针，其本质是一个指向函数的指针，不要和指针函数混淆。

```c++
int test(int a, int b){
    int sum = a + b;
    return sum;
}

int main (){
    int (*p)(int,int); //函数指针的声明，该指针指向有两个整形参数，返回整型的一个函数
    p = test; //函数名就是函数的地址
    cout<<p(10,20); //函数指针可以直接当函数名进行调用
    cout<<(*p)(10,20); //也可以解指针后调用
}
```

## const和指针

const作为修饰词，其在搭配指针使用时非常重要的一个知识就是const修饰的对象是谁。

> 注意使用了const修饰词，必须初始化哦

### 常量指针

常量指针指的是指向一个常量的指针，即指针的值可以更改，但指针的指向的内容无法通过指针更改(指针指向的是常量)。示例如下：

```c++
int a[2] = {1, 2};
const int* p = a; //定义常量指针 也可写为 int const* p = a;

//*p = 5; 报错，无法通过指针更改指向的内容
p++;

cout<<*p<<endl; //输出 2
```

<a id="pointerConstant"></a>
### 指针常量

> 也叫常指针

指针常量指的是指针作为一个常量，即指针的值无法更改，但指针指向的内容可以通过指针更改。示例如下：

```c++
int a[2] = {1, 2};
int* const p = a;

*p = 5;
cout<<a[1]<<endl; //输出

//p++; 报错，指针的值无法更改
```

### const同时修饰指针和常量

```c++
int a[2] = {1, 2};
const int* const p = a;
//*p = 5;
//p++;
//均报错，既不能更改指针的值，也不能通过指针更改指向的内容。
```

## 浅拷贝和深拷贝

对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。

对于简单的类，默认的拷贝构造函数一般就够用了，他会以浅拷贝的方式去构造，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。

但类有<span style="background:#FF9999;">动态分配的内存</span>、<span style="background:#FF9999;">指向其他数据的指针</span>等资源时，浅拷贝就无法胜任了，这时需要显式的定义拷贝构造函数，以完整的拷贝对象的所有数据。

举一个简单的例子：

假设我们自定义一个变长数组

```c++
class A{
    public:
        A(int n); //构造函数
        A(const A &a); //拷贝构造函数
        ~A(); //析构函数
        int& operator[](int i){return *(A_p+i);} //重写[]操作符使其支持读写
        int length() const {return A_len;} //获得数组长度

    private:
        int A_len; //数组长度
        int* A_p; //数组指针
};

A::A(int n){
    this->A_len = n;
    this->A_p = (int*)calloc(A_len, sizeof(int));
}

A::A(const A &a){
    this->A_len = a.A_len;
    this->A_p = (int*)calloc(this->A_len, sizeof(int));
    memcpy(this->A_p, a.A_p, this->A_len*sizeof(int));
}

A::~A(){
    free(A_p);
}
```

再来写一个打印函数

```c++
void printA(const A& arr){
    int n = arr.length();
    for(int i = 0; i < n; i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}
```

在`main`函数中测试一下

```c++
int main(){
    A arr1(10); //调用构造函数
    for(int i = 0; i < arr1.length(); i++){
        arr1[i] = i; //循环赋值
    }
    
    A arr2(arr1); //调用拷贝构造函数
    arr2[2] = 100; //改一个值
    
    cout<<"arr1: ";
    printA(arr1);
    cout<<"arr2: ";
    printA(arr2);
}
```

输出结果如下

```
arr1: 0 1 2 3 4 5 6 7 8 9 
arr2: 0 1 100 3 4 5 6 7 8 9 
```

可以看出，我们显式的重构了拷贝构造函数，它<span style="background:#FF9999;">除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来</span>。这样做的结果是，<span style="background:#FF9999;">原有对象和新对象所持有的动态内存是相互独立的</span>，更改一个对象的数据不会影响另外一个对象。

接下来我们将重构的拷贝构造函数注释掉，使A类使用默认的拷贝构造函数，不改变`main`函数，重新编译一下，结果为

```
arr1: 0 1 100 3 4 5 6 7 8 9 
arr2: 0 1 100 3 4 5 6 7 8 9 
```

可以看到更改arr2的同时arr1也发生了改变。不仅如此，在编译时会在析构函数中中断，这是由于浅拷贝导致的arr1和arr2的数组指针指向的是同一个内存空间，在arr1和arr2生命周期结束后系统分别调用了其析构函数，出现了指针悬挂的问题。也可以理解为上文[野指针产生原因](#functionParametersAndPointers)的第2点，即arr1的指针指向的数组所在的内存空间被释放，但此时仍有另一个指针指向该空间，成了野指针。

![](https://cdn.jsdelivr.net/gh/sirosaqqara/picHosting/img/2022/04/20/144706.png)

当然我们也可以换更直观的方式，在注释掉重构的拷贝构造函数后，修改一下`main`函数，在打印完`arr1`后手动调用。

```c++
int main(){
    A arr1(10); //调用构造函数
    for(int i = 0; i < arr1.length(); i++){
        arr1[i] = i; //循环赋值
    }
    
    A arr2(arr1); //调用拷贝构造函数
    arr2[2] = 100; //改一个值
    
    cout<<"arr1: ";
    printA(arr1);
    arr1.~A(); //手动调用析构函数
    cout<<"arr2: ";
    printA(arr2);
}
```

输出结果如下

```
arr1: 0 1 2 3 4 5 6 7 8 9 
arr2: 14556832 0 14549328 0 -17891602 -17891602 -17891602 -17891602 -17891602 -17891602
```

## 引用

虽然标题叫指针和引用，怎么没有一点引用的知识呢？这不就来了吗。

### 引用的概述

引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*。引用（reference）是c++对c语言的重要扩充。引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。其格式为：类型 &引用变量名 = 已定义过的变量名。

引用的特点：

1. 一个变量可取多个别名。

2. 引用必须初始化。

3. 引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量。

### 引用的应用

#### 引用做函数参数

这个部分和上文的[指针做函数参数](#functionParametersAndPointers)类似，同样可以通过形参改变实参。

#### 引用做函数返回值

当函数返回值作为<span style="background:#FF9999;">左值</span> 那么函数的返回值类型必须是<span style="background:#FF9999;">引用</span>。

```c++
int& test(){
    static int num = 10;
    cout<<"num = "<<num<<endl;
    return num;
}

int main(){
    test() = 20;
    test();
}

// 输出结果
// num = 10
// num = 20
```

### 引用的本质

c++编译器在编译过程中使用[指针常量](#pointerConstant)作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。

引用可以理解为指针常量的封装。

```c++
int data = 10;
int &a = data;//a就是data的别名
//编译器内存转换：int * const a = &data;
```

这也是为什么引用的特点：

* 必须初始化（因为指针常量必须初始化）
* 只能在初始化时引用一次，不能改为应用其他变量（因为指针常量的值不能更改）
* 可以通过引用修改元素的值（因为指针常量可以更改指向的值）

### 常引用

> 我一直觉得C++中有些命名就是为了恶心你

常引用就是加入`const`修饰的引用

```c++
int data = 10;
int &a = data;
// 编译器内存转换：int * const a = &data;
const int &b = data;
// 编译器内存转换：const int* const b = &data;
```

结合引用的本质，实际上就是`const`既修饰常量又修饰指针，其值不可更改，指向的值也不可更改，多用于只读的函数中传递参数。
